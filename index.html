<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqiuzhifeng.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="随堂笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="浅秋之枫">
<meta property="og:url" content="https://qianqiuzhifeng.github.io/index.html">
<meta property="og:site_name" content="浅秋之枫">
<meta property="og:description" content="随堂笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="浅秋之枫">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://qianqiuzhifeng.github.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>浅秋之枫</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">浅秋之枫</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">浅秋之枫</p>
  <div class="site-description" itemprop="description">随堂笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/11/k8s-objects-annotation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/11/k8s-objects-annotation/" class="post-title-link" itemprop="url">k8s-对象注释</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-11 16:24:35 / 修改时间：17:04:58" itemprop="dateCreated datePublished" datetime="2020-12-11T16:24:35+08:00">2020-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>可以使用 k8s 注释将任意非标识元数据附加到对象。工具和库等客户端可以检索此元数据。</p>
<h2 id="对象添加元数据"><a href="#对象添加元数据" class="headerlink" title="对象添加元数据"></a>对象添加元数据</h2><p>可以使用标签或注释将元数据附加到 k8s 对象。标签可用于选择对象和查找满足特定条件的对象集合。相反，注释不用于标识和选择对象。注释中的元数据可以大可以小，可以是结构化的，也可以是非结构化的，还可以包含标签不允许的字符。</p>
<p>注释和标签一样，也是键值对集合：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">  &quot;annotations&quot;: &#123;</span><br><span class="line">    &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line">    &quot;key2&quot; : &quot;value2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一些可以记录在注释中的信息示例:</p>
<ul>
<li><p>由声明性配置层管理的字段。将这些字段作为注释附加，可以将它们与客户机或服务器设置的默认值、自动生成的字段和由自动调整大小或自动伸缩系统设置的字段区分开来。</p>
</li>
<li><p>构建、发布或图像信息，如时间戳、发布 id、git 分支、PR 号、图像散列和注册表地址。</p>
</li>
<li><p>指向日志记录、监视、分析或审计存储库的指针。</p>
</li>
<li><p>可用于调试目的的客户端库或工具信息:例如，名称、版本和构建信息。</p>
</li>
<li><p>用户或者工具/系统来源信息，例如来自其他生态系统组件的相关对象的 url。</p>
</li>
<li><p>轻量级的推出工具元数据:例如，配置或检查点。</p>
</li>
<li><p>负责人员的电话或寻呼机号码，或指定查找信息位置的目录项，如团队网站。</p>
</li>
<li><p>终端用户向实现发送的指令，用于修改行为或使用非标准特性。</p>
</li>
</ul>
<p>可以不使用注释，而将这种类型的信息存储在外部数据库或目录中，但是这样会使生成用于部署、管理、内省等的共享客户机库和工具变得更加困难。</p>
<h2 id="表达式和字符集"><a href="#表达式和字符集" class="headerlink" title="表达式和字符集"></a>表达式和字符集</h2><p>注释是键值对。有效的注释键有两个段:可选的前缀和名称，由斜杠(/)分隔。名称段是必需的，必须小于 63 个字符，开头和结尾为字母数字字符([a-z0-9A-Z])，中间有破折号(-)、下划线(_)、点号(.)和字母数字。前缀是可选的。如果指定，前缀必须是一个 DNS 子域:由点(.)分隔的一系列 DNS 标签，总长度不超过 253 个字符，后跟斜杠(/)。</p>
<p>如果省略了前缀，则将该注释键假定为用户的私有。向最终用户对象添加注释的自动化系统组件(例如 kube-scheduler、kube-controller-manager、kube-apiserver、kubectl 或其他第三方自动化)必须指定一个前缀。</p>
<p>kubernetes.io/和 k8s.io/前缀时为 k8s 核心组件保留的。</p>
<p>例如，这是一个有注释(imageregistry: <a target="_blank" rel="noopener" href="https://hub.docker.com/)%E7%9A%84Pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">https://hub.docker.com/)的Pod配置文件</a>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">annotations-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">imageregistry:</span> <span class="string">&quot;https://hub.docker.com/&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-label-and-selector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-label-and-selector/" class="post-title-link" itemprop="url">k8s-对象标签和选择器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-10 14:21:13" itemprop="dateCreated datePublished" datetime="2020-12-10T14:21:13+08:00">2020-12-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-11 16:25:13" itemprop="dateModified" datetime="2020-12-11T16:25:13+08:00">2020-12-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>标签是一个附加到对象（比如：Pods）上的键值对。标签用于指定对用户有意义和相关的对象的标识属性，但不直接暗示核心系统的语义。标签可以用来组织和选择对象的子集。标签可以在创建时附加到对象上，然后在任何时候添加和修改。每个对象定义一个键值对标签集合。对于每个对象键必须是唯一的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">  &quot;labels&quot;: &#123;</span><br><span class="line">    &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line">    &quot;key2&quot; : &quot;value2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签支持有效的查询和监视，非常适合在 ui 和 CLIs 中使用。非识别信息应该使用<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">注释</a>。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>标签使用户能够以松散耦合的方式将自己的组织结构映射到系统对象上，而不需要客户端存储这些映射。</p>
<p>服务部署和批处理管道通常是多维实体(例如，多个分区或部署、多个发布轨道、多个层、每层有多个微服务)。管理经常需要横切操作，这打破了严格层次结构表示的封装，特别是由基础设施而不是用户决定的严格层次结构。</p>
<p>标签示例：</p>
<ul>
<li>“release” : “stable”, “release” : “canary”</li>
<li>“environment” : “dev”, “environment” : “qa”, “environment” : “production”</li>
<li>“tier” : “frontend”, “tier” : “backend”, “tier” : “cache”</li>
<li>“partition” : “customerA”, “partition” : “customerB”</li>
<li>“track” : “daily”, “track” : “weekly”</li>
</ul>
<p>这些只是常用标签的例子;你可以自由发展自己的习惯。请记住，label 键对于给定对象必须是唯一的。</p>
<h2 id="语法和字符集"><a href="#语法和字符集" class="headerlink" title="语法和字符集"></a>语法和字符集</h2><p>标签是键值对。有效的标签键有两个段:可选的前缀和名称，由斜杠（/）分隔。<br>名称段是必需的，且必须小于 63 个字符，开头和结尾为字母数字字符([a-z0-9A-Z])，中间有破折号(-)、下划线(_)、点号(.)和字母数字。前缀是可选的。如果指定，前缀必须是一个 DNS 子域:由点(.)分隔的一系列 DNS 标签，总长度不超过 253 个字符，后跟斜杠（/）。</p>
<p>如果省略了前缀，则认为 label 键是用户私有的。向最终用户对象添加标签的自动化系统组件(例如 kube-scheduler、kube-controller-manager、kube-apiserver、kubectl 或其他第三方自动化)必须指定一个前缀。</p>
<p>kubernetes.io/和 k8s.io/前缀是为 k8s 核心组件保留的。</p>
<p>有效的标签值必须小于 63 个字符，并且必须为空，或者以字母数字字符([a-z0-9A-Z])开始和结束，字符之间有破折号(-)、下划线(_)、点号(.)和字母数字。</p>
<p>例如，下面是一个 Pod 的配置文件，它有两个标签 environment:production 和 app:nginx：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">label-demo</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">production</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><p>与名称和 uid 不同，标签不提供惟一性。通常，我们希望许多对象都带有相同的标签。</p>
<p>通过标签选择器，客户端（用户）可以识别一个对象集合。标签选择器是 K8s 中的核心分组原语。</p>
<p>API 目前支持两种类型的选择器:基于等式的选择器和基于集合的选择器。标签选择器可以由逗号分隔的多个条件组成。在有多个条件的情况下，必须满足所有条件，因此逗号分隔符充当逻辑和(&amp;&amp;)操作符。</p>
<p>空的或未指定的选择器的语义依赖于上下文，使用选择器的 API 类型应该记录它们的有效性和意义。</p>
<p><strong>注意</strong>：对于某些 API 类型，比如 replicaset，两个实例的标签选择器不能在一个名称空间内重叠，否则控制器会将其视为相互冲突的指令，从而无法确定应该出现多少个副本。</p>
<p><strong>警告</strong>：对于基于等式和基于集合的条件，没有逻辑 OR(||)操作符。确保过滤器语句的结构是相应的。</p>
<h3 id="相等条件"><a href="#相等条件" class="headerlink" title="相等条件"></a>相等条件</h3><p>基于相等或不相等的条件允许根据标签键和值进行过滤。匹配对象必须满足所有指定的标签约束，尽管它们也可能有额外的标签。允许使用三种操作符=、==、!=。前两个表示相等(只是同义词)，而后一个表示不相等。例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment = production</span><br><span class="line">tier != frontend</span><br></pre></td></tr></table></figure>

<p>前者选择一切以 environment 为键、值为 production 的资源。后者选择键 tier 对应值不等于 frontend 的所有资源，以及所有没有带 tier 键标签的资源。可以使用逗号分隔符过滤在 production 环境但是不包含 frontend 的资源，比如：environment=production,tier!=frontend</p>
<p>基于相等的标签条件的一个使用场景是让 Pods 指定节点选择标准。例如，下面的示例 Pod 选择标签为“accelerator=nvidia-tesla-p100”的节点。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cuda-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cuda-test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">&quot;k8s.gcr.io/cuda-vector-add:v0.1&quot;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">nvidia.com/gpu:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">accelerator:</span> <span class="string">nvidia-tesla-p100</span></span><br></pre></td></tr></table></figure>

<h3 id="集合条件"><a href="#集合条件" class="headerlink" title="集合条件"></a>集合条件</h3><p>基于集的标签条件允许根据一组值过滤键。支持三种操作符:in、notin 和 exists(仅为键标识符)。例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">environment in (production, qa)</span><br><span class="line">tier notin (frontend, backend)</span><br><span class="line">partition</span><br><span class="line">!partition</span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>URL 请求：</p>
<ul>
<li>相等条件: ?labelSelector=environment%3Dproduction,tier%3Dfrontend</li>
<li>集合条件: ?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</li>
</ul>
<p>kubectl 指令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l environment=production,tier=frontend</span><br><span class="line">kubectl get pods -l &#x27;environment in (production),tier in (frontend)&#x27;</span><br><span class="line">kubectl get pods -l &#x27;environment in (production, qa)&#x27;</span><br><span class="line">kubectl get pods -l &#x27;environment,environment notin (frontend)&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="设置-API-对象引用"><a href="#设置-API-对象引用" class="headerlink" title="设置 API 对象引用"></a>设置 API 对象引用</h3><p>一些 k8s 对象(比如<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">services</a>和<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/">replicationcontrollers</a>)通过标签选择器查找其他资源（比如 Pods）</p>
<h3 id="Service-和-ReplicationController"><a href="#Service-和-ReplicationController" class="headerlink" title="Service 和 ReplicationController"></a>Service 和 ReplicationController</h3><p>服务目标的 pods 集是用标签选择器定义的。类似地，replicationcontroller 应该管理的 pods 的填充也使用标签选择器定义。</p>
<p>这两个对象的标签选择器使用映射在 json 或 yaml 文件中定义，并且只支持基于平等的需求选择器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;selector&quot;: &#123;</span><br><span class="line">    &quot;component&quot; : &quot;redis&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">component:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>

<h3 id="资源也支持集合条件"><a href="#资源也支持集合条件" class="headerlink" title="资源也支持集合条件"></a>资源也支持集合条件</h3><p>最新的资源，比如<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">Job</a>，Deployment，ReplicaSet，和 DaemonSet 支持集合条件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">matchExpressions:</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">tier</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">cache</span>] &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">environment</span>, <span class="attr">operator:</span> <span class="string">NotIn</span>, <span class="attr">values:</span> [<span class="string">dev</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>matchLabels 是{key,value}对的映射。matchLabels 映射中的单个{key,value}等价于 matchexpression 中的一个元素，该元素的键字段为“key”，操作符为“in”，而 values 数组只包含“value”。matchexpression 是 pod 选择器需求的列表。有效的操作符包括 In、NotIn、Exists 和 DoesNotExist。对于 in 和 NotIn，设置的值必须是非空的。匹配标签和匹配表达式的所有要求都是用沙子处理在一起的——为了进行匹配，它们都必须得到满足。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-namespace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-namespace/" class="post-title-link" itemprop="url">k8s-objects-namespace</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 13:54:54 / 修改时间：14:19:11" itemprop="dateCreated datePublished" datetime="2020-12-10T13:54:54+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>k8s 支持由同一物理集群支持的多个虚拟集群。这些虚拟集群称为 namespaces。</p>
<h2 id="何时使用多个命名空间"><a href="#何时使用多个命名空间" class="headerlink" title="何时使用多个命名空间"></a>何时使用多个命名空间</h2><p>namespace 用于跨多个团队或项目有许多用户的环境中。对于有几个到几十个用户的集群，您根本不需要创建或考虑 namespace。当您需要 namespace 提供的特性时，请开始使用 namespace。</p>
<p>namespace 为名称提供一个作用域。资源的名称在 namespace 内必须是惟一的，但不能跨 namespace。namespace 不能相互嵌套，每个 k8s 资源只能在一个 namespace 中。</p>
<p>namespace 是在多个用户之间划分集群资源的一种方式。</p>
<p>没有必要使用多个 namespace 来分隔稍微不同的资源，例如同一软件的不同版本:使用标签来区分同一 namespace 内的资源。</p>
<h2 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/namespaces">命名空间管理指南文档</a>中描述了命名空间的创建和删除。</p>
<p><strong>注意</strong>：避免创建前缀为 kube-的命名空间，因为它是为 k8s 系统命名空间保留的。</p>
<h3 id="查看命名空间"><a href="#查看命名空间" class="headerlink" title="查看命名空间"></a>查看命名空间</h3><p>可以列出集群中当前命名空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespace</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   1d</span><br><span class="line">kube-node-lease   Active   1d</span><br><span class="line">kube-public       Active   1d</span><br><span class="line">kube-system       Active   1d</span><br></pre></td></tr></table></figure>

<p>K8s 从四个初始命名空间开始：</p>
<ul>
<li>default：没有其他命名空间资源的默认命名空间。</li>
<li>kube-system：k8s 系统为对象创建的命名空间。</li>
<li>kube-public：此命名空间是自动创建的，所有用户(包括未经过身份验证的用户)都可读。这个命名空间主要是为集群使用保留的，以防某些资源在整个集群中是可见的和可读的。这个命名空间的公共方面只是一种约定，而不是要求。</li>
<li>kube-node-lease：这个命名空间用于与每个节点关联的租赁对象，它可以随着集群的扩展提高节点的性能。</li>
</ul>
<h3 id="为请求设置命名空间"><a href="#为请求设置命名空间" class="headerlink" title="为请求设置命名空间"></a>为请求设置命名空间</h3><p>可以使用–namespace标志为当前请求设置命名空间。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx --image=nginx --namespace=&lt;insert-namespace-name-here&gt;</span><br><span class="line">kubectl get pods --namespace=&lt;insert-namespace-name-here&gt;</span><br></pre></td></tr></table></figure>

<h3 id="设置命名空间首选项"><a href="#设置命名空间首选项" class="headerlink" title="设置命名空间首选项"></a>设置命名空间首选项</h3><p>您可以在该上下文中永久保存所有后续kubectl命令的命名空间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl config set-context --current --namespace=&lt;insert-namespace-name-here&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Validate it</span></span><br><span class="line">kubectl config view --minify | grep namespace:</span><br></pre></td></tr></table></figure>

<h3 id="命名空间和DNS"><a href="#命名空间和DNS" class="headerlink" title="命名空间和DNS"></a>命名空间和DNS</h3><p>当您创建一个服务时，它会创建一个相应的DNS条目。此条目的形式为<service-name>.<namespace-name>.vcs.cluster.local，这意味着如果容器只使用<service-name>，它将解析为一个命名空间本地的服务。这对于跨多个命名空间(如开发、登台和生产)使用相同的配置非常有用。如果希望跨命名空间访问，则需要使用完全限定域名(FQDN)。</p>
<h3 id="并非所有对象都在名称空间中"><a href="#并非所有对象都在名称空间中" class="headerlink" title="并非所有对象都在名称空间中"></a>并非所有对象都在名称空间中</h3><p>大多数k8s资源(例如pods、服务、复制控制器和其他资源)都位于某些命名空间中。然而，命令空间资源本身并不在命名空间中。底层资源，比如节点和persistentvolume，不存在于任何命名空间中。</p>
<p>查看哪些Kubernetes资源在名称空间中，哪些不在：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> In a namespace</span></span><br><span class="line">kubectl api-resources --namespaced=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Not <span class="keyword">in</span> a namespace</span></span><br><span class="line">kubectl api-resources --namespaced=false</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-name-and-id/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-name-and-id/" class="post-title-link" itemprop="url">k8s-对象名称和ID</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 13:35:11 / 修改时间：13:51:47" itemprop="dateCreated datePublished" datetime="2020-12-10T13:35:11+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>集群中的每个对象都有一个针对该类型资源的惟一名称。每个 k8s 对象还有一个在整个集群中唯一的 UID。</p>
<p>例如，在同一个名称空间中只能有一个名为 myapp-1234 的 Pod，但是可以有一个名为 myapp-1234 的 Pod 和一个 Deployment。</p>
<p>对于用户提供的非唯一属性，k8s 提供<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">标签</a>和<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">注释</a>。</p>
<h2 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h2><p>客户端提供的引用资源 URL 中的对象的字符串，例如：/api/v1/pods/some-name。</p>
<p>一次只能有一个给定类型的对象具有给定名称。但是，如果删除该对象，则可以创建具有相同名称的新对象。</p>
<p>下面是三种常用的资源名称约束。</p>
<h3 id="DNS-Subdomain-Names"><a href="#DNS-Subdomain-Names" class="headerlink" title="DNS Subdomain Names"></a>DNS Subdomain Names</h3><p>大多数资源类型需要一个可以作为 RFC 1123 中定义的 DNS 子域名的名称。这意味着名称必须：</p>
<ul>
<li>包含不超过 253 个字符</li>
<li>只包含小写字母数字字符，’-‘或’.’。</li>
<li>以字母数字字符开始。</li>
<li>以字母数字字符结束。</li>
</ul>
<h3 id="DNS-Label-Names"><a href="#DNS-Label-Names" class="headerlink" title="DNS Label Names"></a>DNS Label Names</h3><p>一些资源类型要求它们的名称遵循 RFC 1123 中定义的 DNS 标签标准。这意味着名称必须：</p>
<ul>
<li>最多包含 63 个字符</li>
<li>只包含小写字母数字字符或“-”</li>
<li>以字母数字字符开始。</li>
<li>以字母数字字符结束。</li>
</ul>
<h3 id="Path-Segment-Names"><a href="#Path-Segment-Names" class="headerlink" title="Path Segment Names"></a>Path Segment Names</h3><p>些资源类型要求它们的名称能够安全地编码为路径段。换句话说，名字可能不是“.”或“..”，也不能包含“/”和“%”。</p>
<p><strong>注意</strong>：有些资源类型对它们的名称有额外的限制。</p>
<h2 id="UIDs"><a href="#UIDs" class="headerlink" title="UIDs"></a>UIDs</h2><p>k8s 系统生成的惟一标识对象的字符串。</p>
<p>在 k8s 集群的整个生命周期中创建的每个对象都有一个独特的 UID。它的目的是区分历史上发生的类似实体。</p>
<p>k8s 的 uid 是普遍唯一的标识符(也称为 uuid)。uuid 被标准化为 ISO/IEC 9834-8 和 ITU-T X.667。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-management/" class="post-title-link" itemprop="url">k8s-objects-management</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 11:02:14 / 修改时间：14:13:45" itemprop="dateCreated datePublished" datetime="2020-12-10T11:02:14+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>kubectl 命令行工具支持几种不同的方法来创建和管理 k8s 对象。本文档提供了不同方法的概述。阅读<a target="_blank" rel="noopener" href="https://kubectl.docs.kubernetes.io/">Kubectl book</a>，了解 Kubectl 管理对象的细节。</p>
<h2 id="管理方法"><a href="#管理方法" class="headerlink" title="管理方法"></a>管理方法</h2><p><strong>注意</strong>：k8s 对象应该只使用一种技术进行管理。同一对象的混合和匹配技术会导致未知的行为。</p>
<table>
<thead>
<tr>
<th align="center">Management technique</th>
<th align="center">Operates on</th>
<th align="center">Recommended environment</th>
<th align="center">Supported writers</th>
<th align="center">Learning curve</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Imperative commands</td>
<td align="center">Live objects</td>
<td align="center">Development projects</td>
<td align="center">1+</td>
<td align="center">Lowest</td>
</tr>
<tr>
<td align="center">Imperative object configuration</td>
<td align="center">Individual files</td>
<td align="center">Production projects</td>
<td align="center">1</td>
<td align="center">Moderate</td>
</tr>
<tr>
<td align="center">Declarative object configuration</td>
<td align="center">Directories of files</td>
<td align="center">Production projects</td>
<td align="center">1+</td>
<td align="center">Highest</td>
</tr>
</tbody></table>
<h2 id="命令行指令"><a href="#命令行指令" class="headerlink" title="命令行指令"></a>命令行指令</h2><p>在使用命令行指令时，用户直接操作集群中的活动对象。用户将操作作为参数或标志提供给 kubectl 指令。</p>
<p>这是在集群中启动或运行一次性任务的最简单方法。由于此技术直接在活动对象上操作，因此不提供以前配置的历史记录。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>通过创建一个部署对象来运行 nginx 容器的实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image nginx</span><br></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>与对象配置相比的优势：</p>
<ul>
<li>命令很简单，容易学习和记忆。</li>
<li>命令只需要一个步骤就可以对集群进行更改。</li>
</ul>
<p>与对象配置相比的缺点：</p>
<ul>
<li>命令不能与变更审查过程集成。</li>
<li>命令不提供与更改关联的审计跟踪。</li>
<li>命令不提供记录源，除了活动的记录。</li>
<li>命令不提供创建新对象的模板。</li>
</ul>
<h2 id="命令式对象配置"><a href="#命令式对象配置" class="headerlink" title="命令式对象配置"></a>命令式对象配置</h2><p>在命令式对象配置中，kubectl 命令指定操作(创建、替换等)、可选标志和至少一个文件名。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。</p>
<p><strong>注意</strong>：命令式的 replace 命令用新提供的规范替换现有规范，删除配置文件中缺少的对对象的所有更改。这种方法不应该用于规范独立于配置文件更新的资源类型。例如，LoadBalancer 类型的服务将独立于集群的配置更新其 externalIPs 字段。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>创建一个定义在配置文件中的对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx.yaml</span><br></pre></td></tr></table></figure>

<p>删除在两个配置文件中定义的对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx.yaml -f redis.yaml</span><br></pre></td></tr></table></figure>

<p>通过覆盖在线配置升级由配置定义的对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace -f nginx.yaml</span><br></pre></td></tr></table></figure>

<h3 id="比较-1"><a href="#比较-1" class="headerlink" title="比较"></a>比较</h3><p>与命令式指令相比的优势：</p>
<ul>
<li>对象配置可以存储在 Git 等源代码控制系统中。</li>
<li>对象配置可以与过程集成，例如在推送前检查更改和审计跟踪。</li>
<li>对象配置提供了创建新对象的模板。</li>
</ul>
<p>与命令式指令相比的缺点：</p>
<ul>
<li>对象配置需要对对象模式有基本的了解。</li>
<li>对象配置需要额外的步骤来编写 YAML 文件。</li>
</ul>
<p>与声明式对象配置相比的优点：</p>
<ul>
<li>命令式对象配置行为更简单，更容易理解。</li>
<li>在 k8s 1.5 版本中，命令式对象配置更加成熟。</li>
</ul>
<p>与声明式对象配置相比的缺点:</p>
<ul>
<li>命令式对象配置最适合文件，而不是目录。</li>
<li>对活动对象的更新必须反映在配置文件中，否则它们将在下一次替换时丢失。</li>
</ul>
<h2 id="声明式对象配置"><a href="#声明式对象配置" class="headerlink" title="声明式对象配置"></a>声明式对象配置</h2><p>当使用声明式对象配置时，用户操作本地存储的对象配置文件，但是用户不定义要对文件执行的操作。kubectl 会自动检测每个对象的创建、更新和删除操作。这允许在目录上工作，不同的对象可能需要不同的操作。</p>
<p><strong>注意</strong>：声明式对象配置保留其他编写者所做的更改，即使这些更改没有合并回对象配置文件。这可以通过使用 patch API 操作来只编写观察到的差异，而不是使用 replace API 操作来替换整个对象配置来实现。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>处理configs目录中的所有对象配置文件，并创建或修补活动对象。可以首先进行diff来查看将要进行的更改，然后应用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -f configs/</span><br><span class="line">kubectl apply -f configs/</span><br></pre></td></tr></table></figure>

<p>递归处理目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -R -f configs/</span><br><span class="line">kubectl apply -R -f configs/</span><br></pre></td></tr></table></figure>

<h3 id="比较-2"><a href="#比较-2" class="headerlink" title="比较"></a>比较</h3><p>与命令式对象配置相比的优势：</p>
<ul>
<li>直接对活动对象所做的更改将被保留，即使它们没有合并回配置文件中。</li>
<li>声明式对象配置更好地支持对每个对象进行目录操作和自动检测操作类型(创建、修补、删除)。</li>
</ul>
<p>与命令式对象配置相比的缺点：</p>
<ul>
<li>声明式对象配置更难调试和理解意外的结果。</li>
<li>使用diffs的部分更新创建复杂的合并和补丁操作。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-knowledge/" class="post-title-link" itemprop="url">k8s-对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 09:53:32 / 修改时间：10:57:05" itemprop="dateCreated datePublished" datetime="2020-12-10T09:53:32+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这个页面解释了 k8s 对象如何在 k8s API 中表示，以及如何用.yaml 格式表示它们。</p>
<h2 id="理解-k8s-对象"><a href="#理解-k8s-对象" class="headerlink" title="理解 k8s 对象"></a>理解 k8s 对象</h2><p>k8s 对象是 k8s 系统中的持久化实体。k8s 使用这些实体来表示集群的状态。具体来说，他们可以描述：</p>
<ul>
<li>哪种容器应用在运行（在哪个节点）</li>
<li>应用资源可用性</li>
<li>应用策略，比如重启、升级和容错</li>
</ul>
<p>k8s 对象是一个“意图记录”，一旦您创建了对象，k8s 系统将不断工作以确保对象的存在。通过创建对象，可以有效地告诉 k8s 系统希望集群的工作负载是什么样子;这是集群所需的状态。</p>
<p>要使用 k8s 对象，无论是创建、修改还是删除它们——都需要使用 k8s API。例如，当使用 kubectl 命令行接口时，CLI 会为您进行必要的 k8s API 调用。还可以在程序中使用其中一个客户端库直接使用 k8s API。</p>
<h2 id="对象-spec-和-status"><a href="#对象-spec-和-status" class="headerlink" title="对象 spec 和 status"></a>对象 spec 和 status</h2><p>几乎每个 k8s 对象都包含两个嵌套的对象字段，它们管理对象的配置:object spec 和 object status。对于具有 spec 的对象，您必须在创建对象时对其进行设置，提供您希望资源具有的特征的描述:它的期望状态。</p>
<p>status 描述对象的当前状态，由 k8s 系统及其组件提供和更新。K8s 控制层持续地、积极地管理每个对象的实际状态，以匹配您提供的所需状态。</p>
<p>例如:在 k8s 中，部署是表示集群上运行的应用程序的对象。在创建部署时，可以设置部署 spec，以指定要运行应用程序的三个副本。K8s 系统读取部署 spec 并开始的三个实例所需的应用程序——更新状态以匹配您的 spec。如果这些实例失败(状态改变),K8s 系统响应 spec 之间的差异和状态进行校正,在这种情况下,开始替代实例。</p>
<p>有关对象 spec、status 和 metadata 的更多信息，请参见 k8s API 约定。</p>
<h2 id="描述-k8s-对象"><a href="#描述-k8s-对象" class="headerlink" title="描述 k8s 对象"></a>描述 k8s 对象</h2><p>在 k8s 中创建对象时，必须提供描述其所需状态的对象 spec，以及关于对象的一些基本信息(如名称)。当使用 k8s API 创建对象时(直接或通过 kubectl)，该 API 请求必须在请求主体中以 JSON 的形式包含该信息。通常，您在.yaml 文件中向 kubectl 提供信息。kubectl 在发出 API 请求时将信息转换为 JSON。</p>
<p>下面是一个示例.yaml 文件，它显示了 Kubernetes 部署所需的字段和对象规范：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>使用像上面那样的.yaml 文件创建部署的一种方法是在 kubectl 命令行界面中使用 kubectl apply 命令，将.yaml 文件作为参数传递。这里有一个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record</span><br></pre></td></tr></table></figure>

<p>输出类似：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deployment.apps/nginx-deployment created</span><br></pre></td></tr></table></figure>

<h3 id="必填属性"><a href="#必填属性" class="headerlink" title="必填属性"></a>必填属性</h3><p>在要创建的 k8s 对象的.yaml 文件中，需要为以下字段设置值：</p>
<ul>
<li>apiVersion：创建对象时使用的 k8s API 版本</li>
<li>kind: 想要创建的资源类型</li>
<li>metadata：帮助惟一标识对象的数据，包括名称字符串、UID 和可选命名空间</li>
<li>spec：描述对象的状态</li>
</ul>
<p>每个 k8s 对象的对象规范的精确格式都不同，并且包含特定于该对象的嵌套字段。<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/">k8s API reference</a>可以帮助您找到可以使用 k8s 创建的所有对象的规范格式。例如，Pod 的规范格式可以在 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#podspec-v1-core">PodSpec v1 core</a> 中找到，而部署的规范格式可以在 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#deploymentspec-v1-apps">DeploymentSpec v1 apps</a> 中找到。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-api-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-api-server/" class="post-title-link" itemprop="url">k8s-api-server</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 09:09:05 / 修改时间：09:51:45" itemprop="dateCreated datePublished" datetime="2020-12-10T09:09:05+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>k8s 控制平台的核心是 API server， API server 暴露 HTTP API 给终端用户、集群中的不同部分以及组件之间的通信。</p>
<p>k8s API 允许你查询和操作 k8s API 中对象（例如：Pods、Namespaces、ConfigMaps 和 Events）的状态。</p>
<p>大多数操作可以通过 kubectl 命令行工具或者其他命令行工具（比如：kubeadm）执行。当然你也可以直接通过 REST 调用执行 API。</p>
<h2 id="OpenAPI-规范"><a href="#OpenAPI-规范" class="headerlink" title="OpenAPI 规范"></a>OpenAPI 规范</h2><p>使用 OpenAPI 记录完整的 API 文档。</p>
<p>k8s API 提供一个以/openapi/v2 为端点的 OpenAPI。可以通过在请求头里加入以下数据来获取对应的响应格式：</p>
<table>
<thead>
<tr>
<th align="left">Header</th>
<th align="left">Possible values</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept-Encoding</td>
<td align="left">gzip</td>
<td align="left">not supplying this header is also acceptable</td>
</tr>
<tr>
<td align="left">Accept</td>
<td align="left">application/com.github.proto-openapi.spec.v2@v1.0+protobuf</td>
<td align="left">mainly for intra-cluster use</td>
</tr>
<tr>
<td align="left">Accept</td>
<td align="left">application/json</td>
<td align="left">default</td>
</tr>
<tr>
<td align="left">Accept</td>
<td align="left">*</td>
<td align="left">serves application/json</td>
</tr>
</tbody></table>
<p>Kubernetes 实现了一种替代的基于 Protobuf 的序列化格式，主要用于集群内通信。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>k8s 通过将对象的序列化状态保存到 etcd 中完成持久化操作。</p>
<h2 id="API-分组和版本"><a href="#API-分组和版本" class="headerlink" title="API 分组和版本"></a>API 分组和版本</h2><p>为了更容易地消除字段或重构资源表示，k8s 支持多个 API 版本，每个版本在不同的 API 路径上，例如：/api/v1 or /apis/rbac.authorization.k8s.io/v1alpha1。</p>
<p>版本控制是在 API 级别而不是在资源或属性级别进行的，以确保 API 提供对系统资源和行为的清晰、一致的视图，并支持对生命周期以及实验 API 的控制访问。</p>
<p>为了使它更容易发展和扩展它的 API, k8s 实现了可以启用或禁用的 API 组。</p>
<p>API 资源由它们的 API 组、资源类型、命名空间(命令空间内的资源)和名称来区分。API 服务器透明地处理 API 版本之间的转换:所有不同版本实际上是相同持久化数据的表示。API 服务器可以通过多个 API 版本提供相同的底层数据。</p>
<p>例如，假设对于同一资源有两个 API 版本，v1 和 v1beta1。如果最初使用 v1beta1 版本的 API 创建对象，那么以后可以使用 v1beta1 或 v1 API 版本读取、更新或删除该对象。</p>
<h3 id="API-变更"><a href="#API-变更" class="headerlink" title="API 变更"></a>API 变更</h3><p>任何成功的系统都需要随着新应用场景出现或现有应用场景的变化而成长和变化。因此，k8s 设计了 k8s API 来不断变化和增长。k8s 项目的目标是不破坏与现有客户机的兼容性，并在一段时间内保持这种兼容性，以便其他项目有机会进行调整。</p>
<p>通常，可以经常地添加新的 API 资源和新的资源字段。删除资源或字段需要遵循 API 弃用策略。</p>
<p>k8s 强烈承诺，一旦官方 k8s API 达到通用可用性(GA)，就会维护其兼容性，通常是在 API 版本 v1。此外，k8s 在可行的情况下保持了 beta API 版本的兼容性:如果采用 beta API，即使在特性稳定之后，也可以继续使用该 API 与集群交互。</p>
<p><strong>注意</strong>：尽管 k8s 还致力于维护 alpha api 版本的兼容性，但在某些情况下，这是不可能的。如果您使用任何 alpha API 版本，请在升级集群时检查 k8s 的发布说明，以防 API 发生更改。</p>
<h2 id="API-扩展"><a href="#API-扩展" class="headerlink" title="API 扩展"></a>API 扩展</h2><p>k8s API 可以通过以下两种方式进行扩展：</p>
<ul>
<li>自定义资源允许您以声明的方式定义 API 服务器应该如何提供所选资源 API。</li>
<li>还可以通过实现聚合层来扩展 k8s API。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/09/k8s-feature-gates/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/09/k8s-feature-gates/" class="post-title-link" itemprop="url">k8s-feature-gates</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-09 18:59:56 / 修改时间：18:59:46" itemprop="dateCreated datePublished" datetime="2020-12-09T18:59:56+08:00">2020-12-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/09/k8s-component-api-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/09/k8s-component-api-server/" class="post-title-link" itemprop="url">k8s-tool-api-server</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-09 15:17:08" itemprop="dateCreated datePublished" datetime="2020-12-09T15:17:08+08:00">2020-12-09</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-10 09:57:53" itemprop="dateModified" datetime="2020-12-10T09:57:53+08:00">2020-12-10</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>K8s API server 验证和配置 API 对象的数据，这些对象包括 pods、服务、复制控制器等。API server 为 REST 操作提供服务，并为集群提供共享状态前端，所有其他组件都通过该状态进行交互。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kube-apiserver [flags]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">类型</th>
<th align="left">默认值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">–add-dir-header</td>
<td align="left">boolean</td>
<td align="left"></td>
<td align="left">如果为 true，将增加文件夹到日志消息的头里</td>
</tr>
<tr>
<td align="left">–advertise-address</td>
<td align="left">ip</td>
<td align="left"></td>
<td align="left">向集群成员发布 apiserver 的 IP 地址。集群的其他节点必须可以访问该地址。如果为空，则使用–bind-address。如果未指定–bind-address，将使用主机的默认接口</td>
</tr>
<tr>
<td align="left">–allow-privileged</td>
<td align="left">boolean</td>
<td align="left">false</td>
<td align="left">如果为 true,表示允许特权容器。默认为 false</td>
</tr>
<tr>
<td align="left">–anonymous-auth</td>
<td align="left">boolean</td>
<td align="left">true</td>
<td align="left">是否允许匿名访问 API server 的安全接口。未被其他身份验证方法拒绝的请求被视为匿名请求。匿名请求的用户名为 system:Anonymous，组名为 system:unauthenticated。默认为 true</td>
</tr>
<tr>
<td align="left">–api-audiences</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">API 的标识符。service account 令牌身份验证器将验证针对 API 使用的令牌至少绑定到其中一个受众。如果配置了–service-account-issuer 标志而未配置此标志，则此字段默认为包含发行者 URL 的单个元素列表。</td>
</tr>
<tr>
<td align="left">–apiserver-count</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left">集群中运行的 apiservers 数量必须为正数。(在–endpoint-reconciler-type=master-count 启用时使用)，默认为 1</td>
</tr>
<tr>
<td align="left">–audit-log-batch-buffer-size</td>
<td align="left">int</td>
<td align="left">10000</td>
<td align="left">在批处理和写入之前存储事件的缓冲区的大小。只在批处理模式下使用，默认为 10000</td>
</tr>
<tr>
<td align="left">–audit-log-batch-max-size</td>
<td align="left">int</td>
<td align="left">1</td>
<td align="left">批处理数量的最大值。只在批处理模式下使用，默认为 1</td>
</tr>
<tr>
<td align="left">–audit-log-batch-max-wait</td>
<td align="left">duration</td>
<td align="left"></td>
<td align="left">强制写入尚未达到最大大小的批处理之前等待的时间。只在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-log-batch-throttle-burst</td>
<td align="left">int</td>
<td align="left"></td>
<td align="left">如果以前没有使用 ThrottleQPS，则同时发送的最大请求数。只在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-log-batch-throttle-enable</td>
<td align="left">boolean</td>
<td align="left"></td>
<td align="left">是否启用批处理节流。只在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-log-batch-throttle-qps</td>
<td align="left">float32</td>
<td align="left"></td>
<td align="left">每秒最大平均批处理数。只在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-log-compress</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">如果设置，则使用 gzip 压缩轮换的日志文件。</td>
</tr>
<tr>
<td align="left">–audit-log-format</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">保存审计日志的格式。“legacy”表示每个事件的一行文本格式。“json”表示结构化 json 格式。已知的格式是 legacy 和 json。</td>
</tr>
<tr>
<td align="left">–audit-log-maxage</td>
<td align="left">int</td>
<td align="left"></td>
<td align="left">根据文件名中编码的时间戳保留旧审计日志文件的最大天数。</td>
</tr>
<tr>
<td align="left">–audit-log-maxbackup</td>
<td align="left">int</td>
<td align="left"></td>
<td align="left">要保留的旧审计日志文件的最大数目。</td>
</tr>
<tr>
<td align="left">–audit-log-maxsize</td>
<td align="left">int</td>
<td align="left"></td>
<td align="left">轮换审计日志文件之前的最大大小(以兆字节为单位)。</td>
</tr>
<tr>
<td align="left">–audit-log-mode</td>
<td align="left">string</td>
<td align="left">Blocking</td>
<td align="left">发送审计事件的策略。Blocking 表示发送事件应该阻塞服务器响应。Batch 导致后端异步地缓冲和编写事件。已知的模式是 Batch、Blocking、blocking-strict。默认是 Blocking</td>
</tr>
<tr>
<td align="left">–audit-log-path</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">如果设置，所有进入 apiserver 的请求都将被记录到该文件中。“-”的意思是标准输出。</td>
</tr>
<tr>
<td align="left">–audit-log-truncate-enabled</td>
<td align="left">boolean</td>
<td align="left"></td>
<td align="left">是否启用了事件和批处理截断</td>
</tr>
<tr>
<td align="left">–audit-log-truncate-max-batch-size</td>
<td align="left">int</td>
<td align="left">10485760</td>
<td align="left">发送到基础后端批处理的最大大小。实际的序列化大小可能要大数百个字节。如果一个批超过这个限制，它将被分割成几个更小的批。默认值为 10485760</td>
</tr>
<tr>
<td align="left">–audit-log-truncate-max-event-size</td>
<td align="left">int</td>
<td align="left">102400</td>
<td align="left">发送到底层后端审计事件的最大大小。如果事件的大小大于这个数字，则删除第一个请求和响应，如果这不能充分减少大小，则丢弃事件。默认值为 102400</td>
</tr>
<tr>
<td align="left">–audit-log-version</td>
<td align="left">string</td>
<td align="left">audit.k8s.io/v1</td>
<td align="left">用于序列化写入日志的审计事件的 API 组和版本。默认为 audit.k8s.io/v1</td>
</tr>
<tr>
<td align="left">–audit-policy-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">定义审计策略的文件地址</td>
</tr>
<tr>
<td align="left">–audit-webhook-batch-buffer-size</td>
<td align="left">int</td>
<td align="left">10000</td>
<td align="left">在批处理和写入之前存储事件的缓冲区的大小。只在批处理模式下使用。默认为 10000</td>
</tr>
<tr>
<td align="left">–audit-webhook-batch-max-size</td>
<td align="left">int</td>
<td align="left"></td>
<td align="left">批处理的最大大小。只在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-webhook-batch-max-size</td>
<td align="left">int</td>
<td align="left">400</td>
<td align="left">批次的最大大小。 仅在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-webhook-batch-max-wait</td>
<td align="left">duration</td>
<td align="left">默认值：30s</td>
<td align="left">强制写入尚未达到最大大小的批处理之前要等待的时间。 仅在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-webhook-batch-throttle-burst</td>
<td align="left">int</td>
<td align="left">默认值：15</td>
<td align="left">如果之前未使用 ThrottleQPS，则同时发送的最大请求数。 仅在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-webhook-batch-throttle-enable</td>
<td align="left">boolean</td>
<td align="left">默认值：true</td>
<td align="left">是否启用了批量限制。 仅在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-webhook-batch-throttle-qps</td>
<td align="left">float32</td>
<td align="left">默认值：10</td>
<td align="left">每秒的最大平均批次数。 仅在批处理模式下使用。</td>
</tr>
<tr>
<td align="left">–audit-webhook-config-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">定义审计 webhook 配置的 kubeconfig 格式文件的路径。</td>
</tr>
<tr>
<td align="left">–audit-webhook-initial-backoff</td>
<td align="left">duration</td>
<td align="left">默认值：10s</td>
<td align="left">重试第一个失败的请求之前要等待的时间。</td>
</tr>
<tr>
<td align="left">–audit-webhook-mode</td>
<td align="left">string</td>
<td align="left">默认值：”batch”</td>
<td align="left">发送审计事件的策略。 阻止（Blocking）表示发送事件应阻止服务器响应。 批处理导致后端异步缓冲和写入事件。 已知的模式是批处理（batch），阻塞（blocking），严格阻塞（blocking-strict）。</td>
</tr>
<tr>
<td align="left">–audit-webhook-truncate-enabled</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">是否启用事件和批处理截断。</td>
</tr>
<tr>
<td align="left">–audit-webhook-truncate-max-batch-size</td>
<td align="left">int</td>
<td align="left">默认值：10485760</td>
<td align="left">发送到下层后端的批次的最大数据量。 实际的序列化大小可能会增加数百个字节。 如果一个批次超出此限制，则将其分成几个较小的批次。</td>
</tr>
<tr>
<td align="left">–audit-webhook-truncate-max-event-size</td>
<td align="left">int</td>
<td align="left">默认值：102400</td>
<td align="left">发送到下层后端的批次的最大数据量。 如果事件的大小大于此数字，则将删除第一个请求和响应， 并且如果事件和事件的大小没有足够减小，则将丢弃事件。</td>
</tr>
<tr>
<td align="left">–audit-webhook-version</td>
<td align="left">string</td>
<td align="left">默认值：”audit.k8s.io/v1”</td>
<td align="left">用于序列化写入 Webhook 的审计事件的 API 组和版本。</td>
</tr>
<tr>
<td align="left">–authentication-token-webhook-cache-ttl</td>
<td align="left">duration</td>
<td align="left">默认值：2m0s</td>
<td align="left">来自 Webhook 令牌身份验证器的缓存响应的持续时间。</td>
</tr>
<tr>
<td align="left">–authentication-token-webhook-config-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">包含 Webhook 配置的文件，用于以 kubeconfig 格式进行令牌认证。 API 服务器将查询远程服务，以对持有者令牌进行身份验证。</td>
</tr>
<tr>
<td align="left">–authentication-token-webhook-version</td>
<td align="left">string</td>
<td align="left">默认值：”v1beta1”</td>
<td align="left">与 Webhook 之间交换 authentication.k8s.io TokenReview 时使用的 API 版本。</td>
</tr>
<tr>
<td align="left">–authorization-mode</td>
<td align="left">stringSlice</td>
<td align="left">默认值：[AlwaysAllow]</td>
<td align="left">在安全端口上进行鉴权的插件的顺序列表。 逗号分隔的列表：AlwaysAllow,AlwaysDeny,ABAC,Webhook,RBAC,Node。</td>
</tr>
<tr>
<td align="left">–authorization-policy-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">包含安全策略的文件，其内容为分行 JSON 格式， 在安全端口上与 –authorization-mode=ABAC 一起使用。</td>
</tr>
<tr>
<td align="left">–authorization-webhook-cache-authorized-ttl</td>
<td align="left">duration</td>
<td align="left">默认值：5m0s</td>
<td align="left">缓存来自 Webhook 鉴权组件的 “授权（authorized）” 响应的持续时间。</td>
</tr>
<tr>
<td align="left">–authorization-webhook-cache-unauthorized-ttl</td>
<td align="left">duration</td>
<td align="left">默认值：30s</td>
<td align="left">缓存来自 Webhook 鉴权模块的 “未授权（unauthorized）” 响应的持续时间。</td>
</tr>
<tr>
<td align="left">–authorization-webhook-config-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">包含 Webhook 配置的文件，其格式为 kubeconfig， 与 –authorization-mode=Webhook 一起使用。 API 服务器将查询远程服务，以对 API 服务器的安全端口的访问执行鉴权。</td>
</tr>
<tr>
<td align="left">–authorization-webhook-version</td>
<td align="left">string</td>
<td align="left">默认值：”v1beta1”</td>
<td align="left">与 Webhook 之间交换 authorization.k8s.io SubjectAccessReview 时使用的 API 版本。</td>
</tr>
<tr>
<td align="left">–azure-container-registry-config</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">包含 Azure 容器仓库配置信息的文件的路径。</td>
</tr>
<tr>
<td align="left">–bind-address</td>
<td align="left">ip</td>
<td align="left">默认值：0.0.0.0</td>
<td align="left">监听 –secure-port 端口的 IP 地址。 集群的其余部分以及 CLI/web 客户端必须可以访问关联的接口。 如果为空白或未指定地址（0.0.0.0 或 ::），则将使用所有接口。</td>
</tr>
<tr>
<td align="left">–cert-dir</td>
<td align="left">string</td>
<td align="left">默认值：”/var/run/kubernetes”</td>
<td align="left">TLS 证书所在的目录。 如果提供了 –tls-cert-file 和 –tls-private-key-file，则将忽略此标志。</td>
</tr>
<tr>
<td align="left">–client-ca-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">如果已设置，则使用与客户端证书的 CommonName 对应的标识对任何出示由 client-ca 文件中的授权机构之一签名的客户端证书的请求进行身份验证。</td>
</tr>
<tr>
<td align="left">–cloud-config</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">云厂商配置文件的路径。 空字符串表示无配置文件。</td>
</tr>
<tr>
<td align="left">–cloud-provider</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">云服务提供商。 空字符串表示没有云厂商。</td>
</tr>
<tr>
<td align="left">–cloud-provider-gce-l7lb-src-cidrs</td>
<td align="left">cidrs</td>
<td align="left">默认值：130.211.0.0/22,35.191.0.0/16</td>
<td align="left">在 GCE 防火墙中打开 CIDR，以进行 L7 LB 流量代理和运行状况检查</td>
</tr>
<tr>
<td align="left">–contention-profiling</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">如果启用了性能分析，则启用锁争用性能分析</td>
</tr>
<tr>
<td align="left">–cors-allowed-origins</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">CORS 允许的来源清单，以逗号分隔。 允许的来源可以是支持子域匹配的正则表达式。 如果此列表为空，则不会启用 CORS。</td>
</tr>
<tr>
<td align="left">–default-not-ready-toleration-seconds</td>
<td align="left">int</td>
<td align="left">默认值：300</td>
<td align="left">标明 notReady:NoExecute 的 tolerationSeconds， 默认情况下将其添加到尚未具有此容忍度的每个 pod 中。</td>
</tr>
<tr>
<td align="left">–default-unreachable-toleration-seconds</td>
<td align="left">int</td>
<td align="left">默认值：300</td>
<td align="left">标明 unreachable:NoExecute 的 tolerationSeconds， 默认情况下将其添加到尚未具有此容忍度的每个 pod 中。</td>
</tr>
<tr>
<td align="left">–default-watch-cache-size</td>
<td align="left">int</td>
<td align="left">默认值：100</td>
<td align="left">默认监听（watch）缓存大小。 如果为零，则将为没有设置默认监视大小的资源禁用监视缓存。</td>
</tr>
<tr>
<td align="left">–delete-collection-workers</td>
<td align="left">int</td>
<td align="left">默认值：1</td>
<td align="left">为 DeleteCollection 调用而产生的工作程序数。 这些用于加速名字空间清理。</td>
</tr>
<tr>
<td align="left">–disable-admission-plugins</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">尽管位于默认启用的插件列表中（NamespaceLifecycle、LimitRanger、ServiceAccount、TaintNodesByCondition、Priority、DefaultTolerationSeconds、DefaultStorageClass、StorageObjectInUseProtection、PersistentVolumeClaimResize、RuntimeClass、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、MutatingAdmissionWebhook、ValidatingAdmissionWebhook、ResourceQuota）仍须被禁用的插件。取值为逗号分隔的准入插件列表：AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyEscalatingExec, DenyExecOnPrivileged, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodPreset, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook。</td>
</tr>
<tr>
<td align="left">该标志中插件的顺序无关紧要。</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">–egress-selector-config-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">带有 apiserver 出站选择器配置的文件。</td>
</tr>
<tr>
<td align="left">–enable-admission-plugins</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">除了默认启用的插件（NamespaceLifecycle、LimitRanger、ServiceAccount、TaintNodesByCondition、Priority、DefaultTolerationSeconds、DefaultStorageClass、StorageObjectInUseProtection、PersistentVolumeClaimResize、RuntimeClass、CertificateApproval、CertificateSigning、CertificateSubjectRestriction、DefaultIngressClass、MutatingAdmissionWebhook、ValidatingAdmissionWebhook、ResourceQuota）之外要启用的插件。取值为逗号分隔的准入插件列表：AlwaysAdmit, AlwaysDeny, AlwaysPullImages, CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, DenyEscalatingExec, DenyExecOnPrivileged, EventRateLimit, ExtendedResourceToleration, ImagePolicyWebhook, LimitPodHardAntiAffinityTopology, LimitRanger, MutatingAdmissionWebhook, NamespaceAutoProvision, NamespaceExists, NamespaceLifecycle, NodeRestriction, OwnerReferencesPermissionEnforcement, PersistentVolumeClaimResize, PersistentVolumeLabel, PodNodeSelector, PodPreset, PodSecurityPolicy, PodTolerationRestriction, Priority, ResourceQuota, RuntimeClass, SecurityContextDeny, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook</td>
</tr>
<tr>
<td align="left">该标志中插件的顺序无关紧要。</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">–enable-aggregator-routing</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">允许聚合器将请求路由到端点 IP 而非集群 IP。</td>
</tr>
<tr>
<td align="left">–enable-bootstrap-token-auth</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">启用以允许将 “kube-system” 名字空间中类型为 “bootstrap.kubernetes.io/token” 的 Secret 用于 TLS 引导身份验证。</td>
</tr>
<tr>
<td align="left">–enable-garbage-collector</td>
<td align="left"></td>
<td align="left">默认值：true</td>
<td align="left">启用通用垃圾收集器。 必须与 kube-controller-manager 的相应标志同步。</td>
</tr>
<tr>
<td align="left">–enable-priority-and-fairness</td>
<td align="left"></td>
<td align="left">默认值：true</td>
<td align="left">如果为 true 且启用了 APIPriorityAndFairness 特性门控， 请使用增强的处理程序替换 max-in-flight 处理程序， 以便根据优先级和公平性完成排队和调度。</td>
</tr>
<tr>
<td align="left">–encryption-provider-config</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">包含加密提供程序配置信息的文件，用在 etcd 中所存储的 Secret 上。</td>
</tr>
<tr>
<td align="left">–endpoint-reconciler-type</td>
<td align="left">string</td>
<td align="left">默认值：”lease”</td>
<td align="left">使用端点协调器（master-count, lease, none）</td>
</tr>
<tr>
<td align="left">–etcd-cafile</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">用于保护 etcd 通信的 SSL 证书颁发机构文件。</td>
</tr>
<tr>
<td align="left">–etcd-certfile</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">用于保护 etcd 通信的 SSL 证书文件。</td>
</tr>
<tr>
<td align="left">–etcd-compaction-interval</td>
<td align="left">duration</td>
<td align="left">默认值：5m0s</td>
<td align="left">压缩请求的间隔。 如果为 0，则禁用来自 apiserver 的压缩请求。</td>
</tr>
<tr>
<td align="left">–etcd-count-metric-poll-period</td>
<td align="left">duration</td>
<td align="left">默认值：1m0s</td>
<td align="left">针对每种类型的资源数量轮询 etcd 的频率。 0 禁用度量值收集。</td>
</tr>
<tr>
<td align="left">–etcd-db-metric-poll-interval</td>
<td align="left">duration</td>
<td align="left">默认值：30s</td>
<td align="left">轮询 etcd 和更新度量值的请求间隔。 0 禁用度量值收集</td>
</tr>
<tr>
<td align="left">–etcd-keyfile</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">用于保护 etcd 通信的 SSL 密钥文件。</td>
</tr>
<tr>
<td align="left">–etcd-prefix</td>
<td align="left">string</td>
<td align="left">默认值：”/registry”</td>
<td align="left">要在 etcd 中所有资源路径之前添加的前缀。</td>
</tr>
<tr>
<td align="left">–etcd-servers</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">要连接的 etcd 服务器列表（scheme://ip:port），以逗号分隔。</td>
</tr>
<tr>
<td align="left">–etcd-servers-overrides</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">etcd 服务器针对每个资源的重载设置，以逗号分隔。 单个替代格式：组/资源#服务器（group/resource#servers），其中服务器是 URL，以分号分隔。</td>
</tr>
<tr>
<td align="left">–event-ttl</td>
<td align="left">duration</td>
<td align="left">默认值：1h0m0s</td>
<td align="left">事件的保留时长。</td>
</tr>
<tr>
<td align="left">–external-hostname</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">为此主机生成外部化 URL 时要使用的主机名（例如 Swagger API 文档或 OpenID 发现）。</td>
</tr>
<tr>
<td align="left">–feature-gates</td>
<td align="left">mapStringBool</td>
<td align="left"></td>
<td align="left">一组 key=value 对，用来描述测试性/试验性功能的特性门控（Feature Gate）。可选项有： 参见官方文档</td>
</tr>
<tr>
<td align="left">–goaway-chance</td>
<td align="left">float</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">为防止 HTTP/2 客户端卡在单个 apiserver 上，可启用随机关闭连接（GOAWAY）。 客户端的其他运行中请求将不会受到影响，并且客户端将重新连接， 可能会在再次通过负载平衡器后登陆到其他 apiserver 上。 此参数设置将发送 GOAWAY 的请求的比例。 具有单个 apiserver 或不使用负载平衡器的群集不应启用此功能。 最小值为 0（关闭），最大值为 .02（1/50 请求）； 建议使用 .001（1/1000）。</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-h, –help</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">kube-apiserver 的帮助命令</td>
</tr>
<tr>
<td align="left">–http2-max-streams-per-connection</td>
<td align="left">int</td>
<td align="left"></td>
<td align="left">服务器为客户端提供的 HTTP/2 连接中最大流数的限制。 零表示使用 golang 的默认值。</td>
</tr>
<tr>
<td align="left">–kubelet-certificate-authority</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">证书颁发机构的证书文件的路径。</td>
</tr>
<tr>
<td align="left">–kubelet-client-certificate</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">TLS 的客户端证书文件的路径。</td>
</tr>
<tr>
<td align="left">–kubelet-client-key</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">TLS 客户端密钥文件的路径。</td>
</tr>
<tr>
<td align="left">–kubelet-preferred-address-types</td>
<td align="left">stringSlice</td>
<td align="left">默认值：[Hostname,InternalDNS,InternalIP,ExternalDNS,ExternalIP]</td>
<td align="left">用于 kubelet 连接的首选 NodeAddressTypes 列表。</td>
</tr>
<tr>
<td align="left">–kubelet-timeout</td>
<td align="left">duration</td>
<td align="left">默认值：5s</td>
<td align="left">kubelet 操作超时时间。</td>
</tr>
<tr>
<td align="left">–kubernetes-service-node-port</td>
<td align="left">int</td>
<td align="left"></td>
<td align="left">如果非零，那么 Kubernetes 主服务（由 apiserver 创建/维护）将是 NodePort 类型，使用它作为端口的值。 如果为零，则 Kubernetes 主服务将为 ClusterIP 类型。</td>
</tr>
<tr>
<td align="left">–livez-grace-period</td>
<td align="left">duration</td>
<td align="left"></td>
<td align="left">此选项代表 apiserver 完成启动序列并生效所需的最长时间。 从 apiserver 的启动时间到这段时间为止， /livez 将假定未完成的启动后钩子将成功完成，因此返回 true。当日志机制执行到’文件 :N’时，生成堆栈跟踪</td>
</tr>
<tr>
<td align="left">–log-dir</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">如果为非空，则在此目录中写入日志文件</td>
</tr>
<tr>
<td align="left">–log-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">如果为非空，使用此日志文件</td>
</tr>
<tr>
<td align="left">–log-file-max-size</td>
<td align="left">uint</td>
<td align="left">默认值：1800</td>
<td align="left">定义日志文件可以增长到的最大大小。单位为兆字节。 如果值为 0，则最大文件大小为无限制。</td>
</tr>
<tr>
<td align="left">–log-flush-frequency</td>
<td align="left">duration</td>
<td align="left">默认值：5s</td>
<td align="left">两次日志刷新之间的最大秒数</td>
</tr>
<tr>
<td align="left">–logging-format</td>
<td align="left">string</td>
<td align="left">默认值：”text”</td>
<td align="left">设置日志格式。允许的格式：”text”，”json”。非默认格式不支持以下标志：–add_dir_header、–alsologtostderr、–log_backtrace_at、–log_dir、–log_file、–log_file_max_size、–logtostderr、-skip_headers、-skip_log_headers、-stderrthreshold、-vmodule 和–log-flush-frequency。当前非默认选择为 alpha，并且会随时更改而不会发出警告。</td>
</tr>
<tr>
<td align="left">c –logtostderr</td>
<td align="left"></td>
<td align="left">默认值：true</td>
<td align="left">在标准错误而不是文件中输出日志记录</td>
</tr>
<tr>
<td align="left">–master-service-namespace</td>
<td align="left">string</td>
<td align="left">默认值：”default”</td>
<td align="left">已废弃：应该从其中将 Kubernetes 主服务注入到 Pod 中的名字空间。</td>
</tr>
<tr>
<td align="left">–max-connection-bytes-per-sec</td>
<td align="left">int</td>
<td align="left"></td>
<td align="left">如果不为零，则将每个用户连接限制为该数（字节数/秒）。 当前仅适用于长时间运行的请求。</td>
</tr>
<tr>
<td align="left">–max-mutating-requests-inflight</td>
<td align="left">int</td>
<td align="left">默认值：200</td>
<td align="left">在给定时间内进行中变更类型请求的最大个数。 当超过该值时，服务将拒绝所有请求。 零表示无限制。</td>
</tr>
<tr>
<td align="left">–max-requests-inflight</td>
<td align="left">int</td>
<td align="left">默认值：400</td>
<td align="left">在给定时间内进行中非变更类型请求的最大数量。 当超过该值时，服务将拒绝所有请求。 零表示无限制。</td>
</tr>
<tr>
<td align="left">–min-request-timeout</td>
<td align="left">int</td>
<td align="left">默认值：1800</td>
<td align="left">可选字段，表示处理程序在请求超时前，必须保持其处于打开状态的最小秒数。 当前只对监听（Watch）请求的处理程序有效，它基于这个值选择一个随机数作为连接超时值，以达到分散负载的目的。</td>
</tr>
<tr>
<td align="left">–oidc-ca-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">如果设置该值，将会使用 oidc-ca-file 中的机构之一对 OpenID 服务的证书进行验证， 否则将会使用主机的根 CA 对其进行验证。</td>
</tr>
<tr>
<td align="left">–oidc-client-id</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">OpenID 连接客户端的要使用的客户 ID，如果设置了 oidc-issuer-url，则必须设置这个值。</td>
</tr>
<tr>
<td align="left">–oidc-groups-claim</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">如果提供该值，这个自定义 OpenID 连接声明将被用来设定用户组。 该声明值需要是一个字符串或字符串数组。 此标志为实验性的，请查阅身份认证相关文档进一步了解详细信息。</td>
</tr>
<tr>
<td align="left">–oidc-groups-prefix</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">如果提供，则所有组都将以该值作为前缀，以防止与其他身份认证策略冲突。</td>
</tr>
<tr>
<td align="left">–oidc-issuer-url</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">OpenID 颁发者 URL，只接受 HTTPS 方案。 如果设置该值，它将被用于验证 OIDC JSON Web Token(JWT)。</td>
</tr>
<tr>
<td align="left">–oidc-required-claim</td>
<td align="left">mapStringString</td>
<td align="left"></td>
<td align="left">描述 ID 令牌中必需声明的键值对。 如果设置此值，则会验证 ID 令牌中存在与该声明匹配的值。 重复此标志以指定多个声明。</td>
</tr>
<tr>
<td align="left">–oidc-signing-algs</td>
<td align="left">stringSlice</td>
<td align="left">默认值：[RS256]</td>
<td align="left">允许的 JOSE 非对称签名算法的逗号分隔列表。 若 JWT 所带的 “alg” 标头值不在列表中，则该 JWT 将被拒绝。 取值依据 RFC 7518 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7518#section-3.1">https://tools.ietf.org/html/rfc7518#section-3.1</a> 定义。</td>
</tr>
<tr>
<td align="left">–oidc-username-claim</td>
<td align="left">string</td>
<td align="left">默认值：”sub”</td>
<td align="left">要用作用户名的 OpenID 声明。 请注意，除默认声明（”sub”）以外的其他声明不能保证是唯一且不可变的。 此标志是实验性的，请参阅身份认证文档以获取更多详细信息。</td>
</tr>
<tr>
<td align="left">–oidc-username-prefix</td>
<td align="left">string</td>
<td align="left">如果提供，则所有用户名都将以该值作为前缀。 如果未提供，则除 “email” 之外的用户名声明都会添加颁发者 URL 作为前缀，以避免冲突。 要略过添加前缀处理，请设置值为 “-“。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">–permit-port-sharing</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">如果为 true，则在绑定端口时将使用 SO_REUSEPORT， 这样多个实例可以绑定到同一地址和端口上。[默认值 = false]</td>
</tr>
<tr>
<td align="left">–profiling</td>
<td align="left"></td>
<td align="left">默认值：true</td>
<td align="left">通过 Web 界面启用性能分析 host:port/debug/pprof/</td>
</tr>
<tr>
<td align="left">–proxy-client-cert-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">当必须调用外部程序以处理请求时，用于证明聚合器或者 kube-apiserver 的身份的客户端证书。 包括代理转发到用户 api-server 的请求和调用 Webhook 准入控制插件的请求。 Kubernetes 期望此证书包含来自于 –requestheader-client-ca-file 标志中所给 CA 的签名。 该 CA 在 kube-system 命名空间的 “extension-apiserver-authentication” ConfigMap 中公开。 从 kube-aggregator 收到调用的组件应该使用该 CA 进行各自的双向 TLS 验证。</td>
</tr>
<tr>
<td align="left">–proxy-client-key-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">当必须调用外部程序来处理请求时，用来证明聚合器或者 kube-apiserver 的身份的客户端私钥。 这包括代理转发给用户 api-server 的请求和调用 Webhook 准入控制插件的请求。</td>
</tr>
<tr>
<td align="left">–request-timeout</td>
<td align="left">duration</td>
<td align="left">默认值：1m0s</td>
<td align="left">可选字段，指示处理程序在超时之前必须保持打开请求的持续时间。 这是请求的默认请求超时，但对于特定类型的请求，可能会被 –min-request-timeout 等标志覆盖。</td>
</tr>
<tr>
<td align="left">–requestheader-allowed-names</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">此值为客户端证书通用名称（Common Name）的列表；表中所列的表项可以用来提供用户名， 方式是使用 –requestheader-username-headers 所指定的头部。 如果为空，能够通过–requestheader-client-ca-file 中机构认证的客户端证书都是被允许的。</td>
</tr>
<tr>
<td align="left">–requestheader-client-ca-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">在信任请求头中以 –requestheader-username-headers 指示的用户名之前， 用于验证接入请求中客户端证书的根证书包。 警告：一般不要假定传入请求已被授权。</td>
</tr>
<tr>
<td align="left">–requestheader-extra-headers-prefix</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">用于查验请求头部的前缀列表。建议使用 X-Remote-Extra-。</td>
</tr>
<tr>
<td align="left">–requestheader-group-headers</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">用于查验用户组的请求头部列表。建议使用 X-Remote-Group。</td>
</tr>
<tr>
<td align="left">–requestheader-username-headers</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">用于查验用户名的请求头头列表。建议使用 X-Remote-User。</td>
</tr>
<tr>
<td align="left">–runtime-config</td>
<td align="left">mapStringString</td>
<td align="left"></td>
<td align="left">一组启用或禁用内置 API 的键值对。支持的选项包括：详情见官方文档</td>
</tr>
<tr>
<td align="left">–secure-port</td>
<td align="left">int</td>
<td align="left">默认值：6443</td>
<td align="left">带身份验证和鉴权机制的 HTTPS 服务端口。 不能用 0 关闭。</td>
</tr>
<tr>
<td align="left">–service-account-extend-token-expiration</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">在生成令牌时，启用投射服务帐户到期时间扩展， 这有助于从旧版令牌安全地过渡到绑定的服务帐户令牌功能。 如果启用此标志，则准入插件注入的令牌的过期时间将延长至 1 年，以防止过渡期间发生意外故障， 并忽略 service-account-max-token-expiration 的值。</td>
</tr>
<tr>
<td align="left">–service-account-issuer {service-account-issuer}/.well-known/openid-configuration</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">服务帐号令牌颁发者的标识符。 颁发者将在已办法令牌的 “iss” 声明中检查此标识符。 此值为字符串或 URI。 如果根据 OpenID Discovery 1.0 规范检查此选项不是有效的 URI，则即使特性门控设置为 true， ServiceAccountIssuerDiscovery 功能也将保持禁用状态。 强烈建议该值符合 OpenID 规范：<a target="_blank" rel="noopener" href="https://openid.net/specs/openid-connect-discovery-1_0.html%E3%80%82">https://openid.net/specs/openid-connect-discovery-1_0.html。</a> 实践中，这意味着 service-account-issuer 取值必须是 HTTPS URL。 还强烈建议此 URL 能够在 {service-account-issuer}/.well-known/openid-configuration 处提供 OpenID 发现文档。</td>
</tr>
<tr>
<td align="left">–service-account-jwks-uri</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">覆盖 /.well-known/openid-configuration 提供的发现文档中 JSON Web 密钥集的 URI。 如果发现文档和密钥集是通过 API 服务器外部 （而非自动检测到或被外部主机名覆盖）之外的 URL 提供给依赖方的，则此标志很有用。 仅在启用 ServiceAccountIssuerDiscovery 特性门控的情况下有效。</td>
</tr>
<tr>
<td align="left">–service-account-key-file</td>
<td align="left">stringArray</td>
<td align="left"></td>
<td align="left">包含 PEM 编码的 x509 RSA 或 ECDSA 私钥或公钥的文件，用于验证 ServiceAccount 令牌。 指定的文件可以包含多个键，并且可以使用不同的文件多次指定标志。 如果未指定，则使用 –tls-private-key-file。 提供 –service-account-signing-key 时必须指定。</td>
</tr>
<tr>
<td align="left">–service-account-lookup</td>
<td align="left"></td>
<td align="left">默认值：true</td>
<td align="left">如果为 true，则在身份认证时验证 etcd 中是否存在 ServiceAccount 令牌。</td>
</tr>
<tr>
<td align="left">–service-account-max-token-expiration</td>
<td align="left">duration</td>
<td align="left"></td>
<td align="left">服务帐户令牌发布者创建的令牌的最长有效期。 如果请求有效期大于此值的有效令牌请求，将使用此值的有效期颁发令牌。</td>
</tr>
<tr>
<td align="left">–service-account-signing-key-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">包含服务帐户令牌颁发者当前私钥的文件的路径。 颁发者将使用此私钥签署所颁发的 ID 令牌（需要启用 “TokenRequest” 特性门控）。</td>
</tr>
<tr>
<td align="left">–service-cluster-ip-range</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">CIDR 表示的 IP 范围用来为服务分配集群 IP。 此地址不得与指定给节点或 Pod 的任何 IP 范围重叠。</td>
</tr>
<tr>
<td align="left">–service-node-port-range</td>
<td align="left">portRange</td>
<td align="left">默认值：30000-32767</td>
<td align="left">保留给具有 NodePort 可见性的服务的端口范围。 例如：”30000-32767”。范围的两端都包括在内。</td>
</tr>
<tr>
<td align="left">–show-hidden-metrics-for-version</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">你要显示隐藏指标的先前版本。仅先前的次要版本有意义，不允许其他值。 格式为 <major>.<minor>，例如：”1.16”。 这种格式的目的是确保您有机会注意到下一个版本是否隐藏了其他指标， 而不是在此之后将它们从发行版中永久删除时感到惊讶。</td>
</tr>
<tr>
<td align="left">–shutdown-delay-duration</td>
<td align="left">duration</td>
<td align="left"></td>
<td align="left">延迟终止时间。在此期间，服务器将继续正常处理请求。 端点 /healthz 和 /livez 将返回成功，但是 /readyz 立即返回失败。 在此延迟过去之后，将开始正常终止。 这可用于允许负载平衡器停止向该服务器发送流量。</td>
</tr>
<tr>
<td align="left">–skip-headers</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">如果为 true，日志消息中避免标题前缀</td>
</tr>
<tr>
<td align="left">–skip-log-headers</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">如果为 true，则在打开日志文件时避免标题</td>
</tr>
<tr>
<td align="left">–stderrthreshold</td>
<td align="left">severity</td>
<td align="left">默认值：2</td>
<td align="left">将达到或超过此阈值的日志写到标准错误输出</td>
</tr>
<tr>
<td align="left">–storage-backend</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">持久化存储后端。选项：”etcd3”（默认）。</td>
</tr>
<tr>
<td align="left">–storage-media-type</td>
<td align="left">string</td>
<td align="left">默认值：”application/vnd.kubernetes.protobuf”</td>
<td align="left">用于在存储中存储对象的媒体类型。 某些资源或存储后端可能仅支持特定的媒体类型，并且将忽略此设置。</td>
</tr>
<tr>
<td align="left">–tls-cert-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">包含用于 HTTPS 的默认 x509 证书的文件。（CA 证书（如果有）在服务器证书之后并置）。 如果启用了 HTTPS 服务，并且未提供 –tls-cert-file 和 –tls-private-key-file， 为公共地址生成一个自签名证书和密钥，并将其保存到 –cert-dir 指定的目录中。</td>
</tr>
<tr>
<td align="left">–tls-cipher-suites</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">服务器的密码套件的列表，以逗号分隔。如果省略，将使用默认的 Go 密码套件。首选值：TLS_AES_128_GCM_SHA256、TLS_AES_256_GCM_SHA384、TLS_CHACHA20_POLY1305_SHA256、TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256、TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256、TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA、TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305、TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256、TLS_RSA_WITH_3DES_EDE_CBC_SHA、TLS_RSA_WITH_AES_128_CBC_SHA、TLS_RSA_WITH_AES_128_GCM_SHA256、TLS_RSA_WTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_ECDSA_WITH_RC4_128_SHA、TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256、TLS_ECDHE_RSA_WITH_RC4_128_SHA、TLS_RSA_WITH_AES_128_CBC_SHA256、TLS_RSA_WITH_RC4_128_SHA。</td>
</tr>
<tr>
<td align="left">–tls-min-version</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">支持的最低 TLS 版本。可能的值：VersionTLS10，VersionTLS11，VersionTLS12，VersionTLS13</td>
</tr>
<tr>
<td align="left">–tls-private-key-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">包含匹配 –tls-cert-file 的 x509 证书私钥的文件。</td>
</tr>
<tr>
<td align="left">–tls-sni-cert-key</td>
<td align="left">namedCertKey</td>
<td align="left">默认值：[]</td>
<td align="left">一对 x509 证书和私钥文件路径，（可选）后缀为全限定域名的域名模式列表，可以使用带有通配符的前缀。 域模式也允许使用 IP 地址，但仅当 apiserver 对客户端请求的 IP 地址具有可见性时，才应使用 IP。 如果未提供域模式，则提取证书的名称。 非通配符匹配优先于通配符匹配，显式域模式优先于提取出的名称。 对于多个密钥/证书对，请多次使用 –tls-sni-cert-key。 示例：”example.crt,example.key” 或 “foo.crt,foo.key:*.foo.com,foo.com”。</td>
</tr>
<tr>
<td align="left">–token-auth-file</td>
<td align="left">string</td>
<td align="left"></td>
<td align="left">如果设置该值，这个文件将被用于通过令牌认证来保护 API 服务的安全端口。</td>
</tr>
<tr>
<td align="left">-v, –v</td>
<td align="left">Level</td>
<td align="left"></td>
<td align="left">日志级别详细程度的数字</td>
</tr>
<tr>
<td align="left">–version version[=true]</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">打印版本信息并退出</td>
</tr>
<tr>
<td align="left">–vmodule</td>
<td align="left">moduleSpec</td>
<td align="left"></td>
<td align="left">以逗号分隔的 pattern=N 设置列表，用于文件过滤的日志记录</td>
</tr>
<tr>
<td align="left">–watch-cache</td>
<td align="left"></td>
<td align="left">默认值：true</td>
<td align="left">在 apiserver 中启用监视缓存</td>
</tr>
<tr>
<td align="left">–watch-cache-sizes</td>
<td align="left">stringSlice</td>
<td align="left"></td>
<td align="left">某些资源（pods、nodes 等）的监视缓存大小设置，以逗号分隔。 每个资源对应的设置格式：resource[.group]#size，其中 resource 为小写复数（无版本）， 对于 apiVersion v1（旧版核心 API）的资源要省略 group， 对其它资源要给出 group，size 为一个数字。 启用 watch-cache 时，此功能生效。 某些资源（replicationcontrollers、endpoints、nodes、pods、services、apiservices.apiregistration.k8s.io） 具有通过启发式设置的系统默认值，其他资源默认为 default-watch-cache-size</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/09/k8s-tools-kind-local-registry/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/09/k8s-tools-kind-local-registry/" class="post-title-link" itemprop="url">k8s-kind-local-registry</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-09 15:07:54 / 修改时间：15:14:37" itemprop="dateCreated datePublished" datetime="2020-12-09T15:07:54+08:00">2020-12-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="创建集群和本地仓库"><a href="#创建集群和本地仓库" class="headerlink" title="创建集群和本地仓库"></a>创建集群和本地仓库</h2><p>下面的shell脚本将创建一个本地docker仓库和一个启用它的kind集群。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">set -o errexit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> create registry container unless it already exists</span></span><br><span class="line">reg_name=&#x27;kind-registry&#x27;</span><br><span class="line">reg_port=&#x27;5000&#x27;</span><br><span class="line">running=&quot;$(docker inspect -f &#x27;&#123;&#123;.State.Running&#125;&#125;&#x27; &quot;$&#123;reg_name&#125;&quot; 2&gt;/dev/null || true)&quot;</span><br><span class="line">if [ &quot;$&#123;running&#125;&quot; != &#x27;true&#x27; ]; then</span><br><span class="line">  docker run \</span><br><span class="line">    -d --restart=always -p &quot;$&#123;reg_port&#125;:5000&quot; --name &quot;$&#123;reg_name&#125;&quot; \</span><br><span class="line">    registry:2</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> create a cluster with the <span class="built_in">local</span> registry enabled <span class="keyword">in</span> containerd</span></span><br><span class="line">cat &lt;&lt;EOF | kind create cluster --config=-</span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: kind.x-k8s.io/v1alpha4</span><br><span class="line">containerdConfigPatches:</span><br><span class="line">- |-</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;localhost:$&#123;reg_port&#125;&quot;]</span><br><span class="line">    endpoint = [&quot;http://$&#123;reg_name&#125;:$&#123;reg_port&#125;&quot;]</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> connect the registry to the cluster network</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> (the network may already be connected)</span></span><br><span class="line">docker network connect &quot;kind&quot; &quot;$&#123;reg_name&#125;&quot; || true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Document the <span class="built_in">local</span> registry</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/generic/1755-communicating-a-local-registry</span></span><br><span class="line">cat &lt;&lt;EOF | kubectl apply -f -</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  name: local-registry-hosting</span><br><span class="line">  namespace: kube-public</span><br><span class="line">data:</span><br><span class="line">  localRegistryHosting.v1: |</span><br><span class="line">    host: &quot;localhost:$&#123;reg_port&#125;&quot;</span><br><span class="line">    help: &quot;https://kind.sigs.k8s.io/docs/user/local-registry/&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h2 id="使用镜像库"><a href="#使用镜像库" class="headerlink" title="使用镜像库"></a>使用镜像库</h2><p>可以通过以下方式使用：</p>
<ul>
<li>首先拉取镜像：docker pull gcr.io/google-samples/hello-app:1.0</li>
<li>使用本地镜像库给镜像打tag： docker tag gcr.io/google-samples/hello-app:1.0 localhost:5000/hello-app:1.0</li>
<li>推送到本地镜像库：docker push localhost:5000/hello-app:1.0</li>
<li>使用镜像：kubectl create deployment hello-server –image=localhost:5000/hello-app:1.0</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">浅秋之枫</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
