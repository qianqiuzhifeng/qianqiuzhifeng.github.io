<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqiuzhifeng.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="随堂笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="浅秋之枫">
<meta property="og:url" content="https://qianqiuzhifeng.github.io/index.html">
<meta property="og:site_name" content="浅秋之枫">
<meta property="og:description" content="随堂笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="浅秋之枫">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://qianqiuzhifeng.github.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>浅秋之枫</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">浅秋之枫</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">浅秋之枫</p>
  <div class="site-description" itemprop="description">随堂笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/14/k8s-cluster-architecture-nodes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/14/k8s-cluster-architecture-nodes/" class="post-title-link" itemprop="url">k8s-集群架构-节点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-14 11:44:04" itemprop="dateCreated datePublished" datetime="2020-12-14T11:44:04+08:00">2020-12-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-17 13:04:49" itemprop="dateModified" datetime="2020-12-17T13:04:49+08:00">2020-12-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>K8s 通过将容器放置到 Pods 中以在 Nodes 上运行来运行工作负载。节点可以是虚拟机或者物理机，取决于集群。每个节点都有包含有控制层管理的运行 Pods 的必要服务。</p>
<p>集群通常有几个节点，在学习环境或者资源有限，也可以只有一个节点。</p>
<p>节点上的组件包括 kubelet, container runtime 和 kube-proxy。</p>
<h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>有两种主要方法可以将节点添加到 API server：</p>
<ul>
<li>节点上的 kubelet 自动注册到控制层。</li>
<li>用户手动添加节点对象。</li>
</ul>
<p>在手动创建节点对象或者节点上的 kubelet 自动注册之后，控制层将检查节点是否可用。例如，可以尝试通过以下 json 显示地创建一个节点：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Node&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;10.240.79.157&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;labels&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-first-k8s-node&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>k8s 在内部创建一个节点对象。k8s 检查 kubelet 是否已注册到与节点的 metada.name 字段匹配的 API 服务器。如果节点是健康的（所有服务都正常运行），节点就是和运行 Pod。否则的话，节点就会被任何可用集群忽略，直到节点重新变为可用。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>k8s 保留不可用节点对象并且持续检查这个节点是否变为可用。</li>
<li>管理员想要停止健康检查时，必须删除节点对象。</li>
</ul>
<p>节点的名字必须是一个可用的 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names#dns-subdomain-names">DNS 子域名称</a></p>
<h3 id="节点自动注册"><a href="#节点自动注册" class="headerlink" title="节点自动注册"></a>节点自动注册</h3><p>当 kubelet 标识 –register-node 是 true 时，kubelet 将向 API server 注册自己。这是大多数发行版所使用的首选模式。</p>
<p>对于自动注册，kubelet 使用以下选项启动：</p>
<ul>
<li>–kubeconfig：向 API server 验证自身的凭据路径。</li>
<li>–cloud-provider： 如何与云提供商对话以读取关于其自身的元数据。</li>
<li>–register-node：自动注册 API server。</li>
<li>–register-with-taints：用给定的污染列表注册节点（逗号分割<key>=<value>:<effect>）。如果 register-node 为 false，则无操作。</li>
<li>–node-ip： 节点的 IP 地址。</li>
<li>–node-labels：在集群中注册节点时要添加的标签。（通过<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a>查询强制执行的标签）</li>
<li>–node-status-update-frequency：指定 kubelet 将节点状态提交给 master 的频率。</li>
</ul>
<p>当<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/node/">Node authorization mode</a>和<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a>可用时，k8s 只被授权创建和更新节点资源。</p>
<h2 id="人工节点管理"><a href="#人工节点管理" class="headerlink" title="人工节点管理"></a>人工节点管理</h2><p>可以通过 kubectl 创建和修改节点对象。</p>
<p>当需要手动创建节点时，需要设置 kubelet 标识–register-node=false。</p>
<p>无论–register-node 的设置如何，都可以修改节点对象。比如，可以给已有节点设置标签，或者将它标记为 unschedulable。</p>
<p>可以将节点上的标签与 Pods 上的节点选择器结合使用，以控制调度。例如，可以约束一个 Pod，使其只适合在可用节点的子集上运行。</p>
<p>将节点标记为 unschedulable 可以防止调度器将新 pods 放到该节点上，但不会影响该节点上的现有 pods。作为节点重启或其他维护之前的准备步骤，这非常有用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将节点标记为不可用</span></span><br><span class="line">kubectl cordon $NODENAME</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将pod驱赶到其他节点</span></span><br><span class="line">kubectl drain $NODENAME</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解除不可调度状态</span></span><br><span class="line">kubectl uncordon $NODENAME</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：作为守护进程的一部分的 Pods 允许在不可调度的节点上运行。DaemonSets 通常提供应该在节点上运行的节点本地服务，即使工作负载应用程序正在耗尽节点。</p>
<h2 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h2><p>节点状态包括以下信息：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/#addresses">Address</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/#condition">Conditions</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/#capacity">Capacity and Allocatable</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/#info">Info</a></li>
</ul>
<p>可以使用 kubectl 查看节点状态和其他详情：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node &lt;insert-node-name-here&gt;</span><br></pre></td></tr></table></figure>

<p>下面描述输出的每个部分。</p>
<h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>这些字段的使用取决于云提供商或裸机配置。</p>
<ul>
<li>HostName：由节点的内核报告的主机名。可以通过 kubelet –hostname-override 参数替换。</li>
<li>ExternalIP：通常是外部可路由的节点的 IP 地址(从集群外部可用)。</li>
<li>InternalIP：通常是仅在集群内可路由的节点的 IP 地址。</li>
</ul>
<h3 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h3><p>Conditions 属性描述所有运行节点的状态。</p>
<table>
<thead>
<tr>
<th align="left">Node Condition</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ready</td>
<td align="left">如果节点运行正常并准备接受 pods，则为 True;如果节点运行不正常且不接受 pods，则为 False;如果节点控制器在最后一个节点-monitor-grace-period(缺省值为 40 秒)中没有听到该节点的消息，则为 Unknown。</td>
</tr>
<tr>
<td align="left">DiskPressure</td>
<td align="left">如果磁盘大小存在压力，即磁盘容量较低，则为 True;否则 False</td>
</tr>
<tr>
<td align="left">MemoryPressure</td>
<td align="left">如果节点内存存在压力，即节点内存较低，则为 True;否则 False</td>
</tr>
<tr>
<td align="left">PIDPressure</td>
<td align="left">如果进程存在压力，即节点上有太多进程，则为 True;否则 False</td>
</tr>
<tr>
<td align="left">NetworkUnavailable</td>
<td align="left">如果节点的网络配置不正确，则为 True，否则为 False</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：如果使用命令行工具打印被禁节点的详细信息，条件包括 SchedulingDisabled。在 k8s API 中，SchedulingDisabled 不是一个状态;相反，被封锁的节点在其规范中被标记为 Unschedulable。</p>
<p>节点状态表示为 JSON 对象。例如，下面的结构描述了一个健康的节点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;conditions&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Ready&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;True&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;KubeletReady&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;kubelet is posting ready status&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastHeartbeatTime&quot;</span>: <span class="string">&quot;2019-06-05T18:38:35Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastTransitionTime&quot;</span>: <span class="string">&quot;2019-06-05T11:41:27Z&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果 Ready 的状态保持未知或者 False 的时间超过了 pod-eviction-timeout(kube-controller-manager 的参数)，节点上的所有 Pod 将被节点控制器安排删除。默认的收回超时持续时间是 5 分钟。在某些情况下，当节点不可访问时，API 服务器无法与节点上的 kubelet 通信。在重新建立与 API 服务器的通信之前，不能将删除 pod 的决定通知 kubelet。在此期间，计划删除的 pod 可能会继续运行。</p>
<p>节点控制器在确认 pod 在集群中停止运行之前不会强制删除 pod。可以看到在不可到达的节点上运行的 pods 处于终止状态或未知状态。如果 k8s 无法推断出一个节点是否永久离开了一个集群，那么集群管理员可能需要手动删除节点对象。从 k8s 中删除节点对象将导致从 API 服务器中删除运行在节点上的所有 Pod 对象，并释放它们的名称。</p>
<p>节点生命周期控制器自动创建表示条件的污点。调度程序在将 Pod 分配给节点时将节点的污点考虑在内。Pods 还可以具有允许它们容忍节点污染的容忍度。</p>
<p>有关详细信息，请参见<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition">Taint Nodes By Condition</a>。</p>
<h3 id="Capacity-and-Allocatable"><a href="#Capacity-and-Allocatable" class="headerlink" title="Capacity and Allocatable"></a>Capacity and Allocatable</h3><p>描述节点上可用的资源:CPU、内存和可以调度到节点上的 pod 的最大数量。</p>
<p>Capacity 字段表示一个节点所拥有的资源总量。Allocatable 表示一个节点上可被普通 pod 消耗的资源量。</p>
<p>在学习如何在节点上<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable">保留计算资源</a>时，您可以阅读更多关于容量和可分配资源的信息。</p>
<h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>描述关于节点的一般信息，如内核版本、k8s 版本(kubelet 和 kube-proxy 版本)、Docker 版本(如果使用)和 OS 名称。该信息由 Kubelet 从节点收集。</p>
<h3 id="Node-controller"><a href="#Node-controller" class="headerlink" title="Node controller"></a>Node controller</h3><p>节点控制器是一个 k8s 控制层组件，它管理节点的各个方面。</p>
<p>节点控制器在节点的生命周期中有多种角色。第一种是在注册节点时给节点分配一个 CIDR 块(如果 CIDR 分配打开了)。</p>
<p>第二种方法是使节点控制器的内部节点列表与云提供商的可用机器列表保持最新。当在云环境中运行时，只要某个节点不健康，节点控制器就会询问云提供商该节点的 VM 是否仍然可用。否则，节点控制器将从其节点列表中删除该节点。</p>
<p>第三个是监视节点的健康状况。当一个节点成为不可用时（即节点控制器停止接收心跳出于某些原因，例如由于节点宕机），节点控制器负责更新 NodeReady 的节点状态到 ConditionUnknown(,),然后如果节点仍然是不可用，那么会将节点上所有的 Pods 驱逐(使用优美的终止)。(默认超时是 40s 开始报告 ConditionUnknown, 5m 之后开始驱逐 pod。)节点控制器在节点监视器周期内检查每个节点的状态。</p>
<h3 id="Heartbeats"><a href="#Heartbeats" class="headerlink" title="Heartbeats"></a>Heartbeats</h3><p>由 k8s 节点发送的心跳帮助确定节点的可用性。</p>
<p>心跳有两种形式:NodeStatus 和 Lease 对象的更新。每个节点在 kube-node-lease 名称空间中都有一个相关联的 Lease 对象。Lease 是一种轻量级资源，它可以随着集群的扩展提高节点心跳的性能。</p>
<p>kubelet 负责创建和更新 NodeStatus 和 Lease 对象：</p>
<ul>
<li><p>kubelet 在状态发生变化时更新节点状态，或者在配置的时间间隔内没有更新。NodeStatus 更新的默认间隔是 5 分钟(远远长于无法到达节点的 40 秒默认超时)。</p>
</li>
<li><p>kubelet 每 10 秒创建并更新其租赁对象(默认的更新间隔)。租约更新独立于节点状态更新发生。如果租约更新失败，kubelet 将以指数回退的方式重试，起始时间为 200 毫秒，上限为 7 秒。</p>
</li>
</ul>
<h3 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h3><p>在大多数情况下，节点控制器将回收速率限制为——节点回收速率(默认值为 0.1)每秒，这意味着它每 10 秒不会从超过 1 个节点中回收 pod。</p>
<p>当给定可用性区域中的节点变得不健康时，节点退出行为将发生变化。节点控制器同时检查区域中有多少节点是不健康的(NodeReady 状态是 ConditionUnknown 或 ConditionFalse)。如果不健康的节点的分数至少–unhealthy-zone-threshold (默认 0.55)然后驱逐率是减少:如果集群很小(即小于或等于–large-cluster-size-threshold 节点默认 50)驱逐就停止,否则驱逐率降低到–secondary-node-eviction-rate (默认 0.01)每秒。每个可用性区域实现这些策略的原因是，一个可用性区域可能与主可用性区域分离，而其他可用性区域保持连接。如果您的集群没有跨越多个云提供商可用性区域，那么就只有一个可用性区域(整个集群)。</p>
<p>将节点分布到多个可用性区域的一个关键原因是，这样当整个区域出现故障时，可以将工作负载转移到健康区域。因此，如果一个区域中的所有节点都不健康，那么节点控制器将以正常的节点驱逐率(node-eviction-rate)进行驱逐。最极端的情况是所有区域都完全不健康(即集群中没有健康节点)。在这种情况下，节点控制器假定主连接有问题，并停止所有收回操作，直到恢复某些连接为止。</p>
<p>节点控制器还负责清除运行在带有 NoExecute 污染的节点上的 pod，除非这些 pod 容忍这种污染。节点控制器还添加了与节点问题(如节点不可用或未就绪)相对应的污点。这意味着调度器不会将 pod 放置到不健康的节点上。</p>
<p><strong>警告</strong>：kubectl cordon 将一个节点标记为’unschedulable’，这样做的副作用是服务控制器从任何负载均衡器节点目标列表中删除该节点，它以前是合格的，有效地从被封锁的节点中删除传入的负载均衡器流量。</p>
<h3 id="Node-capacity"><a href="#Node-capacity" class="headerlink" title="Node capacity"></a>Node capacity</h3><p>节点对象跟踪关于节点资源容量的信息(例如:可用内存量和 cpu 数量)。自我注册的节点在注册期间报告它们的容量。如果手动添加节点，则需要在添加节点时设置节点的容量信息。</p>
<p>k8s 调度程序确保一个节点上有足够的资源供所有 pod 使用。调度程序检查该节点上容器请求的总和是否大于该节点的容量。请求的总和包括 kubelet 管理的所有容器，但不包括直接由容器运行时启动的任何容器，也不包括在 kubelet 控制之外运行的任何进程。</p>
<p><strong>注意</strong>：如果希望显式地为非pod进程保留资源，请参阅<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved">系统守护进程的保留资源</a>。<br>`</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/11/k8s-objects-field-selector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/11/k8s-objects-field-selector/" class="post-title-link" itemprop="url">k8s-对象属性选择器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-11 17:08:43" itemprop="dateCreated datePublished" datetime="2020-12-11T17:08:43+08:00">2020-12-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-14 11:41:39" itemprop="dateModified" datetime="2020-12-14T11:41:39+08:00">2020-12-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>属性选择器允许基于一个或多个资源属性获取k8s资源。属性请求的示例：</p>
<ul>
<li>metadata.name=my-service</li>
<li>metadata.namespace!=default</li>
<li>status.phase=Pending</li>
</ul>
<p>使用kubectl命令查询所有status.phase属性值为Running的Pods:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --field-selector status.phase=Running</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 属性选择器本质上是资源过滤器。默认情况下，没有使用选择器或者过滤器，意味着指定类型的所有资源都会被选中。</p>
<h2 id="支持的属性"><a href="#支持的属性" class="headerlink" title="支持的属性"></a>支持的属性</h2><p>受支持的字段选择器因k8s资源类型而异。所有资源类型都支持metadata.name和metadata.namespace字段。使用不支持的字段选择器会产生错误。例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ingress --field-selector foo.bar=baz</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error from server (BadRequest): Unable to find &quot;ingresses&quot; that match label selector &quot;&quot;, field selector &quot;foo.bar=baz&quot;: &quot;foo.bar&quot; is not a known field selector: only &quot;metadata.name&quot;, &quot;metadata.namespace&quot;</span><br></pre></td></tr></table></figure>

<h2 id="支持的运算符"><a href="#支持的运算符" class="headerlink" title="支持的运算符"></a>支持的运算符</h2><p>可以在字段选择器中使用=、==和!=操作符(=和==意思相同)。例如，这个kubectl命令选择不在默认名称空间中的所有K8s服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services  --all-namespaces --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure>

<h2 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h2><p>与标签和其他选择器一样，属性选择器可以作为逗号分隔的列表组合在一起。这个kubectl命令选择状态为其的所有Pods(status.phase不等于Running，spec.restartPolicy等于Always）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always</span><br></pre></td></tr></table></figure>

<h2 id="多个资源类型"><a href="#多个资源类型" class="headerlink" title="多个资源类型"></a>多个资源类型</h2><p>可以跨多个资源类型使用属性选择器。这个kubectl命令选择不在default命名空间中的所有Statefulsets和Services</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/11/k8s-objects-annotation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/11/k8s-objects-annotation/" class="post-title-link" itemprop="url">k8s-对象注释</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-11 16:24:35 / 修改时间：17:04:58" itemprop="dateCreated datePublished" datetime="2020-12-11T16:24:35+08:00">2020-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>可以使用 k8s 注释将任意非标识元数据附加到对象。工具和库等客户端可以检索此元数据。</p>
<h2 id="对象添加元数据"><a href="#对象添加元数据" class="headerlink" title="对象添加元数据"></a>对象添加元数据</h2><p>可以使用标签或注释将元数据附加到 k8s 对象。标签可用于选择对象和查找满足特定条件的对象集合。相反，注释不用于标识和选择对象。注释中的元数据可以大可以小，可以是结构化的，也可以是非结构化的，还可以包含标签不允许的字符。</p>
<p>注释和标签一样，也是键值对集合：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">  &quot;annotations&quot;: &#123;</span><br><span class="line">    &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line">    &quot;key2&quot; : &quot;value2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一些可以记录在注释中的信息示例:</p>
<ul>
<li><p>由声明性配置层管理的字段。将这些字段作为注释附加，可以将它们与客户机或服务器设置的默认值、自动生成的字段和由自动调整大小或自动伸缩系统设置的字段区分开来。</p>
</li>
<li><p>构建、发布或图像信息，如时间戳、发布 id、git 分支、PR 号、图像散列和注册表地址。</p>
</li>
<li><p>指向日志记录、监视、分析或审计存储库的指针。</p>
</li>
<li><p>可用于调试目的的客户端库或工具信息:例如，名称、版本和构建信息。</p>
</li>
<li><p>用户或者工具/系统来源信息，例如来自其他生态系统组件的相关对象的 url。</p>
</li>
<li><p>轻量级的推出工具元数据:例如，配置或检查点。</p>
</li>
<li><p>负责人员的电话或寻呼机号码，或指定查找信息位置的目录项，如团队网站。</p>
</li>
<li><p>终端用户向实现发送的指令，用于修改行为或使用非标准特性。</p>
</li>
</ul>
<p>可以不使用注释，而将这种类型的信息存储在外部数据库或目录中，但是这样会使生成用于部署、管理、内省等的共享客户机库和工具变得更加困难。</p>
<h2 id="表达式和字符集"><a href="#表达式和字符集" class="headerlink" title="表达式和字符集"></a>表达式和字符集</h2><p>注释是键值对。有效的注释键有两个段:可选的前缀和名称，由斜杠(/)分隔。名称段是必需的，必须小于 63 个字符，开头和结尾为字母数字字符([a-z0-9A-Z])，中间有破折号(-)、下划线(_)、点号(.)和字母数字。前缀是可选的。如果指定，前缀必须是一个 DNS 子域:由点(.)分隔的一系列 DNS 标签，总长度不超过 253 个字符，后跟斜杠(/)。</p>
<p>如果省略了前缀，则将该注释键假定为用户的私有。向最终用户对象添加注释的自动化系统组件(例如 kube-scheduler、kube-controller-manager、kube-apiserver、kubectl 或其他第三方自动化)必须指定一个前缀。</p>
<p>kubernetes.io/和 k8s.io/前缀时为 k8s 核心组件保留的。</p>
<p>例如，这是一个有注释(imageregistry: <a target="_blank" rel="noopener" href="https://hub.docker.com/)%E7%9A%84Pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">https://hub.docker.com/)的Pod配置文件</a>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">annotations-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">imageregistry:</span> <span class="string">&quot;https://hub.docker.com/&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-label-and-selector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-label-and-selector/" class="post-title-link" itemprop="url">k8s-对象标签和选择器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-10 14:21:13" itemprop="dateCreated datePublished" datetime="2020-12-10T14:21:13+08:00">2020-12-10</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-11 16:25:13" itemprop="dateModified" datetime="2020-12-11T16:25:13+08:00">2020-12-11</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>标签是一个附加到对象（比如：Pods）上的键值对。标签用于指定对用户有意义和相关的对象的标识属性，但不直接暗示核心系统的语义。标签可以用来组织和选择对象的子集。标签可以在创建时附加到对象上，然后在任何时候添加和修改。每个对象定义一个键值对标签集合。对于每个对象键必须是唯一的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">  &quot;labels&quot;: &#123;</span><br><span class="line">    &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line">    &quot;key2&quot; : &quot;value2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标签支持有效的查询和监视，非常适合在 ui 和 CLIs 中使用。非识别信息应该使用<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">注释</a>。</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>标签使用户能够以松散耦合的方式将自己的组织结构映射到系统对象上，而不需要客户端存储这些映射。</p>
<p>服务部署和批处理管道通常是多维实体(例如，多个分区或部署、多个发布轨道、多个层、每层有多个微服务)。管理经常需要横切操作，这打破了严格层次结构表示的封装，特别是由基础设施而不是用户决定的严格层次结构。</p>
<p>标签示例：</p>
<ul>
<li>“release” : “stable”, “release” : “canary”</li>
<li>“environment” : “dev”, “environment” : “qa”, “environment” : “production”</li>
<li>“tier” : “frontend”, “tier” : “backend”, “tier” : “cache”</li>
<li>“partition” : “customerA”, “partition” : “customerB”</li>
<li>“track” : “daily”, “track” : “weekly”</li>
</ul>
<p>这些只是常用标签的例子;你可以自由发展自己的习惯。请记住，label 键对于给定对象必须是唯一的。</p>
<h2 id="语法和字符集"><a href="#语法和字符集" class="headerlink" title="语法和字符集"></a>语法和字符集</h2><p>标签是键值对。有效的标签键有两个段:可选的前缀和名称，由斜杠（/）分隔。<br>名称段是必需的，且必须小于 63 个字符，开头和结尾为字母数字字符([a-z0-9A-Z])，中间有破折号(-)、下划线(_)、点号(.)和字母数字。前缀是可选的。如果指定，前缀必须是一个 DNS 子域:由点(.)分隔的一系列 DNS 标签，总长度不超过 253 个字符，后跟斜杠（/）。</p>
<p>如果省略了前缀，则认为 label 键是用户私有的。向最终用户对象添加标签的自动化系统组件(例如 kube-scheduler、kube-controller-manager、kube-apiserver、kubectl 或其他第三方自动化)必须指定一个前缀。</p>
<p>kubernetes.io/和 k8s.io/前缀是为 k8s 核心组件保留的。</p>
<p>有效的标签值必须小于 63 个字符，并且必须为空，或者以字母数字字符([a-z0-9A-Z])开始和结束，字符之间有破折号(-)、下划线(_)、点号(.)和字母数字。</p>
<p>例如，下面是一个 Pod 的配置文件，它有两个标签 environment:production 和 app:nginx：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">label-demo</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">production</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h2 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h2><p>与名称和 uid 不同，标签不提供惟一性。通常，我们希望许多对象都带有相同的标签。</p>
<p>通过标签选择器，客户端（用户）可以识别一个对象集合。标签选择器是 K8s 中的核心分组原语。</p>
<p>API 目前支持两种类型的选择器:基于等式的选择器和基于集合的选择器。标签选择器可以由逗号分隔的多个条件组成。在有多个条件的情况下，必须满足所有条件，因此逗号分隔符充当逻辑和(&amp;&amp;)操作符。</p>
<p>空的或未指定的选择器的语义依赖于上下文，使用选择器的 API 类型应该记录它们的有效性和意义。</p>
<p><strong>注意</strong>：对于某些 API 类型，比如 replicaset，两个实例的标签选择器不能在一个名称空间内重叠，否则控制器会将其视为相互冲突的指令，从而无法确定应该出现多少个副本。</p>
<p><strong>警告</strong>：对于基于等式和基于集合的条件，没有逻辑 OR(||)操作符。确保过滤器语句的结构是相应的。</p>
<h3 id="相等条件"><a href="#相等条件" class="headerlink" title="相等条件"></a>相等条件</h3><p>基于相等或不相等的条件允许根据标签键和值进行过滤。匹配对象必须满足所有指定的标签约束，尽管它们也可能有额外的标签。允许使用三种操作符=、==、!=。前两个表示相等(只是同义词)，而后一个表示不相等。例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">environment = production</span><br><span class="line">tier != frontend</span><br></pre></td></tr></table></figure>

<p>前者选择一切以 environment 为键、值为 production 的资源。后者选择键 tier 对应值不等于 frontend 的所有资源，以及所有没有带 tier 键标签的资源。可以使用逗号分隔符过滤在 production 环境但是不包含 frontend 的资源，比如：environment=production,tier!=frontend</p>
<p>基于相等的标签条件的一个使用场景是让 Pods 指定节点选择标准。例如，下面的示例 Pod 选择标签为“accelerator=nvidia-tesla-p100”的节点。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cuda-test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cuda-test</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">&quot;k8s.gcr.io/cuda-vector-add:v0.1&quot;</span></span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">nvidia.com/gpu:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">nodeSelector:</span></span><br><span class="line">    <span class="attr">accelerator:</span> <span class="string">nvidia-tesla-p100</span></span><br></pre></td></tr></table></figure>

<h3 id="集合条件"><a href="#集合条件" class="headerlink" title="集合条件"></a>集合条件</h3><p>基于集的标签条件允许根据一组值过滤键。支持三种操作符:in、notin 和 exists(仅为键标识符)。例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">environment in (production, qa)</span><br><span class="line">tier notin (frontend, backend)</span><br><span class="line">partition</span><br><span class="line">!partition</span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>URL 请求：</p>
<ul>
<li>相等条件: ?labelSelector=environment%3Dproduction,tier%3Dfrontend</li>
<li>集合条件: ?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</li>
</ul>
<p>kubectl 指令:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -l environment=production,tier=frontend</span><br><span class="line">kubectl get pods -l &#x27;environment in (production),tier in (frontend)&#x27;</span><br><span class="line">kubectl get pods -l &#x27;environment in (production, qa)&#x27;</span><br><span class="line">kubectl get pods -l &#x27;environment,environment notin (frontend)&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="设置-API-对象引用"><a href="#设置-API-对象引用" class="headerlink" title="设置 API 对象引用"></a>设置 API 对象引用</h3><p>一些 k8s 对象(比如<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/service/">services</a>和<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/">replicationcontrollers</a>)通过标签选择器查找其他资源（比如 Pods）</p>
<h3 id="Service-和-ReplicationController"><a href="#Service-和-ReplicationController" class="headerlink" title="Service 和 ReplicationController"></a>Service 和 ReplicationController</h3><p>服务目标的 pods 集是用标签选择器定义的。类似地，replicationcontroller 应该管理的 pods 的填充也使用标签选择器定义。</p>
<p>这两个对象的标签选择器使用映射在 json 或 yaml 文件中定义，并且只支持基于平等的需求选择器：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;selector&quot;: &#123;</span><br><span class="line">    &quot;component&quot; : &quot;redis&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">component:</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure>

<h3 id="资源也支持集合条件"><a href="#资源也支持集合条件" class="headerlink" title="资源也支持集合条件"></a>资源也支持集合条件</h3><p>最新的资源，比如<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">Job</a>，Deployment，ReplicaSet，和 DaemonSet 支持集合条件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span></span><br><span class="line">    <span class="attr">component:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">matchExpressions:</span></span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">tier</span>, <span class="attr">operator:</span> <span class="string">In</span>, <span class="attr">values:</span> [<span class="string">cache</span>] &#125;</span><br><span class="line">    <span class="bullet">-</span> &#123; <span class="attr">key:</span> <span class="string">environment</span>, <span class="attr">operator:</span> <span class="string">NotIn</span>, <span class="attr">values:</span> [<span class="string">dev</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>matchLabels 是{key,value}对的映射。matchLabels 映射中的单个{key,value}等价于 matchexpression 中的一个元素，该元素的键字段为“key”，操作符为“in”，而 values 数组只包含“value”。matchexpression 是 pod 选择器需求的列表。有效的操作符包括 In、NotIn、Exists 和 DoesNotExist。对于 in 和 NotIn，设置的值必须是非空的。匹配标签和匹配表达式的所有要求都是用沙子处理在一起的——为了进行匹配，它们都必须得到满足。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-namespace/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-namespace/" class="post-title-link" itemprop="url">k8s-objects-namespace</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 13:54:54 / 修改时间：14:19:11" itemprop="dateCreated datePublished" datetime="2020-12-10T13:54:54+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>k8s 支持由同一物理集群支持的多个虚拟集群。这些虚拟集群称为 namespaces。</p>
<h2 id="何时使用多个命名空间"><a href="#何时使用多个命名空间" class="headerlink" title="何时使用多个命名空间"></a>何时使用多个命名空间</h2><p>namespace 用于跨多个团队或项目有许多用户的环境中。对于有几个到几十个用户的集群，您根本不需要创建或考虑 namespace。当您需要 namespace 提供的特性时，请开始使用 namespace。</p>
<p>namespace 为名称提供一个作用域。资源的名称在 namespace 内必须是惟一的，但不能跨 namespace。namespace 不能相互嵌套，每个 k8s 资源只能在一个 namespace 中。</p>
<p>namespace 是在多个用户之间划分集群资源的一种方式。</p>
<p>没有必要使用多个 namespace 来分隔稍微不同的资源，例如同一软件的不同版本:使用标签来区分同一 namespace 内的资源。</p>
<h2 id="使用命名空间"><a href="#使用命名空间" class="headerlink" title="使用命名空间"></a>使用命名空间</h2><p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/namespaces">命名空间管理指南文档</a>中描述了命名空间的创建和删除。</p>
<p><strong>注意</strong>：避免创建前缀为 kube-的命名空间，因为它是为 k8s 系统命名空间保留的。</p>
<h3 id="查看命名空间"><a href="#查看命名空间" class="headerlink" title="查看命名空间"></a>查看命名空间</h3><p>可以列出集群中当前命名空间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespace</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   1d</span><br><span class="line">kube-node-lease   Active   1d</span><br><span class="line">kube-public       Active   1d</span><br><span class="line">kube-system       Active   1d</span><br></pre></td></tr></table></figure>

<p>K8s 从四个初始命名空间开始：</p>
<ul>
<li>default：没有其他命名空间资源的默认命名空间。</li>
<li>kube-system：k8s 系统为对象创建的命名空间。</li>
<li>kube-public：此命名空间是自动创建的，所有用户(包括未经过身份验证的用户)都可读。这个命名空间主要是为集群使用保留的，以防某些资源在整个集群中是可见的和可读的。这个命名空间的公共方面只是一种约定，而不是要求。</li>
<li>kube-node-lease：这个命名空间用于与每个节点关联的租赁对象，它可以随着集群的扩展提高节点的性能。</li>
</ul>
<h3 id="为请求设置命名空间"><a href="#为请求设置命名空间" class="headerlink" title="为请求设置命名空间"></a>为请求设置命名空间</h3><p>可以使用–namespace标志为当前请求设置命名空间。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl run nginx --image=nginx --namespace=&lt;insert-namespace-name-here&gt;</span><br><span class="line">kubectl get pods --namespace=&lt;insert-namespace-name-here&gt;</span><br></pre></td></tr></table></figure>

<h3 id="设置命名空间首选项"><a href="#设置命名空间首选项" class="headerlink" title="设置命名空间首选项"></a>设置命名空间首选项</h3><p>您可以在该上下文中永久保存所有后续kubectl命令的命名空间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl config set-context --current --namespace=&lt;insert-namespace-name-here&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Validate it</span></span><br><span class="line">kubectl config view --minify | grep namespace:</span><br></pre></td></tr></table></figure>

<h3 id="命名空间和DNS"><a href="#命名空间和DNS" class="headerlink" title="命名空间和DNS"></a>命名空间和DNS</h3><p>当您创建一个服务时，它会创建一个相应的DNS条目。此条目的形式为<service-name>.<namespace-name>.vcs.cluster.local，这意味着如果容器只使用<service-name>，它将解析为一个命名空间本地的服务。这对于跨多个命名空间(如开发、登台和生产)使用相同的配置非常有用。如果希望跨命名空间访问，则需要使用完全限定域名(FQDN)。</p>
<h3 id="并非所有对象都在名称空间中"><a href="#并非所有对象都在名称空间中" class="headerlink" title="并非所有对象都在名称空间中"></a>并非所有对象都在名称空间中</h3><p>大多数k8s资源(例如pods、服务、复制控制器和其他资源)都位于某些命名空间中。然而，命令空间资源本身并不在命名空间中。底层资源，比如节点和persistentvolume，不存在于任何命名空间中。</p>
<p>查看哪些Kubernetes资源在名称空间中，哪些不在：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> In a namespace</span></span><br><span class="line">kubectl api-resources --namespaced=true</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Not <span class="keyword">in</span> a namespace</span></span><br><span class="line">kubectl api-resources --namespaced=false</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-name-and-id/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-name-and-id/" class="post-title-link" itemprop="url">k8s-对象名称和ID</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 13:35:11 / 修改时间：13:51:47" itemprop="dateCreated datePublished" datetime="2020-12-10T13:35:11+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>集群中的每个对象都有一个针对该类型资源的惟一名称。每个 k8s 对象还有一个在整个集群中唯一的 UID。</p>
<p>例如，在同一个名称空间中只能有一个名为 myapp-1234 的 Pod，但是可以有一个名为 myapp-1234 的 Pod 和一个 Deployment。</p>
<p>对于用户提供的非唯一属性，k8s 提供<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/">标签</a>和<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/">注释</a>。</p>
<h2 id="Names"><a href="#Names" class="headerlink" title="Names"></a>Names</h2><p>客户端提供的引用资源 URL 中的对象的字符串，例如：/api/v1/pods/some-name。</p>
<p>一次只能有一个给定类型的对象具有给定名称。但是，如果删除该对象，则可以创建具有相同名称的新对象。</p>
<p>下面是三种常用的资源名称约束。</p>
<h3 id="DNS-Subdomain-Names"><a href="#DNS-Subdomain-Names" class="headerlink" title="DNS Subdomain Names"></a>DNS Subdomain Names</h3><p>大多数资源类型需要一个可以作为 RFC 1123 中定义的 DNS 子域名的名称。这意味着名称必须：</p>
<ul>
<li>包含不超过 253 个字符</li>
<li>只包含小写字母数字字符，’-‘或’.’。</li>
<li>以字母数字字符开始。</li>
<li>以字母数字字符结束。</li>
</ul>
<h3 id="DNS-Label-Names"><a href="#DNS-Label-Names" class="headerlink" title="DNS Label Names"></a>DNS Label Names</h3><p>一些资源类型要求它们的名称遵循 RFC 1123 中定义的 DNS 标签标准。这意味着名称必须：</p>
<ul>
<li>最多包含 63 个字符</li>
<li>只包含小写字母数字字符或“-”</li>
<li>以字母数字字符开始。</li>
<li>以字母数字字符结束。</li>
</ul>
<h3 id="Path-Segment-Names"><a href="#Path-Segment-Names" class="headerlink" title="Path Segment Names"></a>Path Segment Names</h3><p>些资源类型要求它们的名称能够安全地编码为路径段。换句话说，名字可能不是“.”或“..”，也不能包含“/”和“%”。</p>
<p><strong>注意</strong>：有些资源类型对它们的名称有额外的限制。</p>
<h2 id="UIDs"><a href="#UIDs" class="headerlink" title="UIDs"></a>UIDs</h2><p>k8s 系统生成的惟一标识对象的字符串。</p>
<p>在 k8s 集群的整个生命周期中创建的每个对象都有一个独特的 UID。它的目的是区分历史上发生的类似实体。</p>
<p>k8s 的 uid 是普遍唯一的标识符(也称为 uuid)。uuid 被标准化为 ISO/IEC 9834-8 和 ITU-T X.667。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-management/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-management/" class="post-title-link" itemprop="url">k8s-objects-management</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 11:02:14 / 修改时间：14:13:45" itemprop="dateCreated datePublished" datetime="2020-12-10T11:02:14+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>kubectl 命令行工具支持几种不同的方法来创建和管理 k8s 对象。本文档提供了不同方法的概述。阅读<a target="_blank" rel="noopener" href="https://kubectl.docs.kubernetes.io/">Kubectl book</a>，了解 Kubectl 管理对象的细节。</p>
<h2 id="管理方法"><a href="#管理方法" class="headerlink" title="管理方法"></a>管理方法</h2><p><strong>注意</strong>：k8s 对象应该只使用一种技术进行管理。同一对象的混合和匹配技术会导致未知的行为。</p>
<table>
<thead>
<tr>
<th align="center">Management technique</th>
<th align="center">Operates on</th>
<th align="center">Recommended environment</th>
<th align="center">Supported writers</th>
<th align="center">Learning curve</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Imperative commands</td>
<td align="center">Live objects</td>
<td align="center">Development projects</td>
<td align="center">1+</td>
<td align="center">Lowest</td>
</tr>
<tr>
<td align="center">Imperative object configuration</td>
<td align="center">Individual files</td>
<td align="center">Production projects</td>
<td align="center">1</td>
<td align="center">Moderate</td>
</tr>
<tr>
<td align="center">Declarative object configuration</td>
<td align="center">Directories of files</td>
<td align="center">Production projects</td>
<td align="center">1+</td>
<td align="center">Highest</td>
</tr>
</tbody></table>
<h2 id="命令行指令"><a href="#命令行指令" class="headerlink" title="命令行指令"></a>命令行指令</h2><p>在使用命令行指令时，用户直接操作集群中的活动对象。用户将操作作为参数或标志提供给 kubectl 指令。</p>
<p>这是在集群中启动或运行一次性任务的最简单方法。由于此技术直接在活动对象上操作，因此不提供以前配置的历史记录。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>通过创建一个部署对象来运行 nginx 容器的实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create deployment nginx --image nginx</span><br></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>与对象配置相比的优势：</p>
<ul>
<li>命令很简单，容易学习和记忆。</li>
<li>命令只需要一个步骤就可以对集群进行更改。</li>
</ul>
<p>与对象配置相比的缺点：</p>
<ul>
<li>命令不能与变更审查过程集成。</li>
<li>命令不提供与更改关联的审计跟踪。</li>
<li>命令不提供记录源，除了活动的记录。</li>
<li>命令不提供创建新对象的模板。</li>
</ul>
<h2 id="命令式对象配置"><a href="#命令式对象配置" class="headerlink" title="命令式对象配置"></a>命令式对象配置</h2><p>在命令式对象配置中，kubectl 命令指定操作(创建、替换等)、可选标志和至少一个文件名。指定的文件必须包含 YAML 或 JSON 格式的对象的完整定义。</p>
<p><strong>注意</strong>：命令式的 replace 命令用新提供的规范替换现有规范，删除配置文件中缺少的对对象的所有更改。这种方法不应该用于规范独立于配置文件更新的资源类型。例如，LoadBalancer 类型的服务将独立于集群的配置更新其 externalIPs 字段。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>创建一个定义在配置文件中的对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f nginx.yaml</span><br></pre></td></tr></table></figure>

<p>删除在两个配置文件中定义的对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f nginx.yaml -f redis.yaml</span><br></pre></td></tr></table></figure>

<p>通过覆盖在线配置升级由配置定义的对象：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl replace -f nginx.yaml</span><br></pre></td></tr></table></figure>

<h3 id="比较-1"><a href="#比较-1" class="headerlink" title="比较"></a>比较</h3><p>与命令式指令相比的优势：</p>
<ul>
<li>对象配置可以存储在 Git 等源代码控制系统中。</li>
<li>对象配置可以与过程集成，例如在推送前检查更改和审计跟踪。</li>
<li>对象配置提供了创建新对象的模板。</li>
</ul>
<p>与命令式指令相比的缺点：</p>
<ul>
<li>对象配置需要对对象模式有基本的了解。</li>
<li>对象配置需要额外的步骤来编写 YAML 文件。</li>
</ul>
<p>与声明式对象配置相比的优点：</p>
<ul>
<li>命令式对象配置行为更简单，更容易理解。</li>
<li>在 k8s 1.5 版本中，命令式对象配置更加成熟。</li>
</ul>
<p>与声明式对象配置相比的缺点:</p>
<ul>
<li>命令式对象配置最适合文件，而不是目录。</li>
<li>对活动对象的更新必须反映在配置文件中，否则它们将在下一次替换时丢失。</li>
</ul>
<h2 id="声明式对象配置"><a href="#声明式对象配置" class="headerlink" title="声明式对象配置"></a>声明式对象配置</h2><p>当使用声明式对象配置时，用户操作本地存储的对象配置文件，但是用户不定义要对文件执行的操作。kubectl 会自动检测每个对象的创建、更新和删除操作。这允许在目录上工作，不同的对象可能需要不同的操作。</p>
<p><strong>注意</strong>：声明式对象配置保留其他编写者所做的更改，即使这些更改没有合并回对象配置文件。这可以通过使用 patch API 操作来只编写观察到的差异，而不是使用 replace API 操作来替换整个对象配置来实现。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>处理configs目录中的所有对象配置文件，并创建或修补活动对象。可以首先进行diff来查看将要进行的更改，然后应用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -f configs/</span><br><span class="line">kubectl apply -f configs/</span><br></pre></td></tr></table></figure>

<p>递归处理目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl diff -R -f configs/</span><br><span class="line">kubectl apply -R -f configs/</span><br></pre></td></tr></table></figure>

<h3 id="比较-2"><a href="#比较-2" class="headerlink" title="比较"></a>比较</h3><p>与命令式对象配置相比的优势：</p>
<ul>
<li>直接对活动对象所做的更改将被保留，即使它们没有合并回配置文件中。</li>
<li>声明式对象配置更好地支持对每个对象进行目录操作和自动检测操作类型(创建、修补、删除)。</li>
</ul>
<p>与命令式对象配置相比的缺点：</p>
<ul>
<li>声明式对象配置更难调试和理解意外的结果。</li>
<li>使用diffs的部分更新创建复杂的合并和补丁操作。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-objects-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-objects-knowledge/" class="post-title-link" itemprop="url">k8s-对象</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 09:53:32 / 修改时间：10:57:05" itemprop="dateCreated datePublished" datetime="2020-12-10T09:53:32+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>这个页面解释了 k8s 对象如何在 k8s API 中表示，以及如何用.yaml 格式表示它们。</p>
<h2 id="理解-k8s-对象"><a href="#理解-k8s-对象" class="headerlink" title="理解 k8s 对象"></a>理解 k8s 对象</h2><p>k8s 对象是 k8s 系统中的持久化实体。k8s 使用这些实体来表示集群的状态。具体来说，他们可以描述：</p>
<ul>
<li>哪种容器应用在运行（在哪个节点）</li>
<li>应用资源可用性</li>
<li>应用策略，比如重启、升级和容错</li>
</ul>
<p>k8s 对象是一个“意图记录”，一旦您创建了对象，k8s 系统将不断工作以确保对象的存在。通过创建对象，可以有效地告诉 k8s 系统希望集群的工作负载是什么样子;这是集群所需的状态。</p>
<p>要使用 k8s 对象，无论是创建、修改还是删除它们——都需要使用 k8s API。例如，当使用 kubectl 命令行接口时，CLI 会为您进行必要的 k8s API 调用。还可以在程序中使用其中一个客户端库直接使用 k8s API。</p>
<h2 id="对象-spec-和-status"><a href="#对象-spec-和-status" class="headerlink" title="对象 spec 和 status"></a>对象 spec 和 status</h2><p>几乎每个 k8s 对象都包含两个嵌套的对象字段，它们管理对象的配置:object spec 和 object status。对于具有 spec 的对象，您必须在创建对象时对其进行设置，提供您希望资源具有的特征的描述:它的期望状态。</p>
<p>status 描述对象的当前状态，由 k8s 系统及其组件提供和更新。K8s 控制层持续地、积极地管理每个对象的实际状态，以匹配您提供的所需状态。</p>
<p>例如:在 k8s 中，部署是表示集群上运行的应用程序的对象。在创建部署时，可以设置部署 spec，以指定要运行应用程序的三个副本。K8s 系统读取部署 spec 并开始的三个实例所需的应用程序——更新状态以匹配您的 spec。如果这些实例失败(状态改变),K8s 系统响应 spec 之间的差异和状态进行校正,在这种情况下,开始替代实例。</p>
<p>有关对象 spec、status 和 metadata 的更多信息，请参见 k8s API 约定。</p>
<h2 id="描述-k8s-对象"><a href="#描述-k8s-对象" class="headerlink" title="描述 k8s 对象"></a>描述 k8s 对象</h2><p>在 k8s 中创建对象时，必须提供描述其所需状态的对象 spec，以及关于对象的一些基本信息(如名称)。当使用 k8s API 创建对象时(直接或通过 kubectl)，该 API 请求必须在请求主体中以 JSON 的形式包含该信息。通常，您在.yaml 文件中向 kubectl 提供信息。kubectl 在发出 API 请求时将信息转换为 JSON。</p>
<p>下面是一个示例.yaml 文件，它显示了 Kubernetes 部署所需的字段和对象规范：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># for versions before 1.9.0 use apps/v1beta2</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deployment</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span> <span class="comment"># tells deployment to run 2 pods matching the template</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>使用像上面那样的.yaml 文件创建部署的一种方法是在 kubectl 命令行界面中使用 kubectl apply 命令，将.yaml 文件作为参数传递。这里有一个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record</span><br></pre></td></tr></table></figure>

<p>输出类似：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deployment.apps/nginx-deployment created</span><br></pre></td></tr></table></figure>

<h3 id="必填属性"><a href="#必填属性" class="headerlink" title="必填属性"></a>必填属性</h3><p>在要创建的 k8s 对象的.yaml 文件中，需要为以下字段设置值：</p>
<ul>
<li>apiVersion：创建对象时使用的 k8s API 版本</li>
<li>kind: 想要创建的资源类型</li>
<li>metadata：帮助惟一标识对象的数据，包括名称字符串、UID 和可选命名空间</li>
<li>spec：描述对象的状态</li>
</ul>
<p>每个 k8s 对象的对象规范的精确格式都不同，并且包含特定于该对象的嵌套字段。<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/">k8s API reference</a>可以帮助您找到可以使用 k8s 创建的所有对象的规范格式。例如，Pod 的规范格式可以在 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#podspec-v1-core">PodSpec v1 core</a> 中找到，而部署的规范格式可以在 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#deploymentspec-v1-apps">DeploymentSpec v1 apps</a> 中找到。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/10/k8s-api-server/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/10/k8s-api-server/" class="post-title-link" itemprop="url">k8s-api-server</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-10 09:09:05 / 修改时间：09:51:45" itemprop="dateCreated datePublished" datetime="2020-12-10T09:09:05+08:00">2020-12-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>k8s 控制平台的核心是 API server， API server 暴露 HTTP API 给终端用户、集群中的不同部分以及组件之间的通信。</p>
<p>k8s API 允许你查询和操作 k8s API 中对象（例如：Pods、Namespaces、ConfigMaps 和 Events）的状态。</p>
<p>大多数操作可以通过 kubectl 命令行工具或者其他命令行工具（比如：kubeadm）执行。当然你也可以直接通过 REST 调用执行 API。</p>
<h2 id="OpenAPI-规范"><a href="#OpenAPI-规范" class="headerlink" title="OpenAPI 规范"></a>OpenAPI 规范</h2><p>使用 OpenAPI 记录完整的 API 文档。</p>
<p>k8s API 提供一个以/openapi/v2 为端点的 OpenAPI。可以通过在请求头里加入以下数据来获取对应的响应格式：</p>
<table>
<thead>
<tr>
<th align="left">Header</th>
<th align="left">Possible values</th>
<th align="left">Notes</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept-Encoding</td>
<td align="left">gzip</td>
<td align="left">not supplying this header is also acceptable</td>
</tr>
<tr>
<td align="left">Accept</td>
<td align="left">application/com.github.proto-openapi.spec.v2@v1.0+protobuf</td>
<td align="left">mainly for intra-cluster use</td>
</tr>
<tr>
<td align="left">Accept</td>
<td align="left">application/json</td>
<td align="left">default</td>
</tr>
<tr>
<td align="left">Accept</td>
<td align="left">*</td>
<td align="left">serves application/json</td>
</tr>
</tbody></table>
<p>Kubernetes 实现了一种替代的基于 Protobuf 的序列化格式，主要用于集群内通信。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>k8s 通过将对象的序列化状态保存到 etcd 中完成持久化操作。</p>
<h2 id="API-分组和版本"><a href="#API-分组和版本" class="headerlink" title="API 分组和版本"></a>API 分组和版本</h2><p>为了更容易地消除字段或重构资源表示，k8s 支持多个 API 版本，每个版本在不同的 API 路径上，例如：/api/v1 or /apis/rbac.authorization.k8s.io/v1alpha1。</p>
<p>版本控制是在 API 级别而不是在资源或属性级别进行的，以确保 API 提供对系统资源和行为的清晰、一致的视图，并支持对生命周期以及实验 API 的控制访问。</p>
<p>为了使它更容易发展和扩展它的 API, k8s 实现了可以启用或禁用的 API 组。</p>
<p>API 资源由它们的 API 组、资源类型、命名空间(命令空间内的资源)和名称来区分。API 服务器透明地处理 API 版本之间的转换:所有不同版本实际上是相同持久化数据的表示。API 服务器可以通过多个 API 版本提供相同的底层数据。</p>
<p>例如，假设对于同一资源有两个 API 版本，v1 和 v1beta1。如果最初使用 v1beta1 版本的 API 创建对象，那么以后可以使用 v1beta1 或 v1 API 版本读取、更新或删除该对象。</p>
<h3 id="API-变更"><a href="#API-变更" class="headerlink" title="API 变更"></a>API 变更</h3><p>任何成功的系统都需要随着新应用场景出现或现有应用场景的变化而成长和变化。因此，k8s 设计了 k8s API 来不断变化和增长。k8s 项目的目标是不破坏与现有客户机的兼容性，并在一段时间内保持这种兼容性，以便其他项目有机会进行调整。</p>
<p>通常，可以经常地添加新的 API 资源和新的资源字段。删除资源或字段需要遵循 API 弃用策略。</p>
<p>k8s 强烈承诺，一旦官方 k8s API 达到通用可用性(GA)，就会维护其兼容性，通常是在 API 版本 v1。此外，k8s 在可行的情况下保持了 beta API 版本的兼容性:如果采用 beta API，即使在特性稳定之后，也可以继续使用该 API 与集群交互。</p>
<p><strong>注意</strong>：尽管 k8s 还致力于维护 alpha api 版本的兼容性，但在某些情况下，这是不可能的。如果您使用任何 alpha API 版本，请在升级集群时检查 k8s 的发布说明，以防 API 发生更改。</p>
<h2 id="API-扩展"><a href="#API-扩展" class="headerlink" title="API 扩展"></a>API 扩展</h2><p>k8s API 可以通过以下两种方式进行扩展：</p>
<ul>
<li>自定义资源允许您以声明的方式定义 API 服务器应该如何提供所选资源 API。</li>
<li>还可以通过实现聚合层来扩展 k8s API。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/09/k8s-feature-gates/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/09/k8s-feature-gates/" class="post-title-link" itemprop="url">k8s-feature-gates</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-09 18:59:56 / 修改时间：18:59:46" itemprop="dateCreated datePublished" datetime="2020-12-09T18:59:56+08:00">2020-12-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">浅秋之枫</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
