<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"qianqiuzhifeng.github.io","root":"/","images":"/images","scheme":"Muse","version":"8.1.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="随堂笔记">
<meta property="og:type" content="website">
<meta property="og:title" content="浅秋之枫">
<meta property="og:url" content="https://qianqiuzhifeng.github.io/index.html">
<meta property="og:site_name" content="浅秋之枫">
<meta property="og:description" content="随堂笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="浅秋之枫">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://qianqiuzhifeng.github.io/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>浅秋之枫</title>
  



  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">浅秋之枫</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">浅秋之枫</p>
  <div class="site-description" itemprop="description">随堂笔记</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/22/k8s-workload-resources/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/k8s-workload-resources/" class="post-title-link" itemprop="url">k8s-负载-资源</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-22 17:06:40" itemprop="dateCreated datePublished" datetime="2020-12-22T17:06:40+08:00">2020-12-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-28 14:21:59" itemprop="dateModified" datetime="2020-12-28T14:21:59+08:00">2020-12-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/">官方文档</a></p>
<h2 id="Deployments"><a href="#Deployments" class="headerlink" title="Deployments"></a>Deployments</h2><h3 id="Deployments-使用场景"><a href="#Deployments-使用场景" class="headerlink" title="Deployments 使用场景"></a>Deployments 使用场景</h3><ul>
<li>创建部署以推出 ReplicaSet。ReplicaSet 在后台创建 pod。检查 rollout 的状态，看看它是否成功。</li>
<li>通过更新部署的 Pod TemplateSpec 声明 Pods 的新状态。创建一个新的副本集，部署管理将 pod 从旧副本集以可控的速度移动到新副本集。每个新的副本集都会更新部署的修订。</li>
<li>回滚到较早的部署修订。每次回滚都会更新部署的修订。</li>
<li>扩展部署以促进更多负载。</li>
<li>暂停部署，将多个补丁应用到它的 PodTemplateSpec，然后恢复它以开始一个新的 rollout。</li>
<li>使用部署的状态作为一个指示器，表示已经进行了部署。</li>
<li>清理不再需要的旧副本集。</li>
</ul>
<h3 id="Deployment-Spec"><a href="#Deployment-Spec" class="headerlink" title="Deployment Spec"></a>Deployment Spec</h3><p>和其他 k8s 配置一样，部署需要.apiVersion、.kind 和.metadata 字段。部署也需要.spec 部分。</p>
<h4 id="Pod-Template"><a href="#Pod-Template" class="headerlink" title="Pod Template"></a>Pod Template</h4><p>.spec 必须要有.spec.template 和 .spec.selector 字段。</p>
<p>.spec.template 是一个 Pod 模板。和 Pod 有相同的结构，除了它是嵌套并且不包含 apiVersion 和 Kind。</p>
<h4 id="Replicas"><a href="#Replicas" class="headerlink" title="Replicas"></a>Replicas</h4><p>.spec.replicas 是一个可选字段，描述了期望的 Pods 数量，默认为 1。</p>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>.spec.selector 是必填字段，描述了被部署追踪的 Pods 的标签选择器。</p>
<p>.spec.selector 必须和.spec.template.metadata.labels 匹配，否则将会被 API 拒绝。</p>
<p>在 API 版本 apps/v1 中，如果不设置的话，默认情况下.spec.selector 和.metadata.labels 与.spec.template.metadata.labels 不一致。因此它们必须被直接设置。需要注意的是 在创建 apps/v1 的部署后，.spec.selector 不可变。</p>
<p>部署会中断那些标签匹配选择器的 Pods，如果这些 Pods 的 template 不匹配.spec.template，或者 Pods 的总数超过了.spec.replicas。</p>
<p><strong>注意</strong>：您不应该通过创建另一个部署或创建另一个控制器(如 ReplicaSet 或 ReplicationController)直接创建标签与这个选择器匹配的其他 Pods。如果这样做，第一个部署会认为它创建了这些其他的 Pods。k8s 不会阻止你这么做。</p>
<p>如果存在多个拥有重叠选择器的控制器，那么这些控制器将会相互争斗，并不能正确地运行。</p>
<h4 id="Strategy"><a href="#Strategy" class="headerlink" title="Strategy"></a>Strategy</h4><p>.spec.strategy 描述了新老 Pods 替换的策略。.spec.strategy.type 可以是“Recreate”、“RollingUpdate”，默认是“RollingUpdate”。</p>
<h4 id="Recreate-Deployment"><a href="#Recreate-Deployment" class="headerlink" title="Recreate Deployment"></a>Recreate Deployment</h4><p>当.spec.strategy.type==Recreate 时，在新 Pods 创建之前，会 kill 所有已存在的 Pods。</p>
<p><strong>注意</strong>：这将只保证 Pod 终止之前创建升级。如果升级部署，旧版本的所有 pod 将立即终止。在创建新版本的任何 Pod 之前，将等待成功删除。如果您手动删除一个 Pod，生命周期由 ReplicaSet 控制，替换将立即创建(即使旧的 Pod 仍然处于终止状态)。如果您需要“at most”保证您的 pod，您应该考虑使用 StatefulSet。</p>
<h2 id="ReplicaSet"><a href="#ReplicaSet" class="headerlink" title="ReplicaSet"></a>ReplicaSet</h2><h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>StatefulSet 是用来管理有状态应用的负载 API。</p>
<p>管理部署，缩放 Pods 集，并且提供 Pods 顺序和唯一性保证。</p>
<p>与部署一样，StatefulSet 管理基于相同容器规范的 Pods。与部署不同，StatefulSet 为每个 pod 维护一个粘性标识。这些 pod 是根据相同的规范创建的，但不能互换:每个 pod 都有一个持久性标识符，它在任何重新调度过程中都要维护这个标识符。</p>
<p>如果想要使用存储卷给负载提供持久化，你可以使用 StatefulSet 作为一种解决方案。尽管 StatefulSet 中的单个 Pod 容易出现故障，但持久化的 Pod 标识符可以更容易地将现有的卷匹配到替换任何故障的新 Pod。</p>
<h3 id="StatefulSet-使用场景"><a href="#StatefulSet-使用场景" class="headerlink" title="StatefulSet 使用场景"></a>StatefulSet 使用场景</h3><p>StatefulSets 对于需要以下一种或多种功能的应用程序很有价值。</p>
<ul>
<li><p>稳定、唯一的网络标识符。</p>
</li>
<li><p>稳定、持久的存储。</p>
</li>
<li><p>有序、优雅的部署和扩展。</p>
</li>
<li><p>有序、自动滚蛋升级。</p>
</li>
</ul>
<p>在上面的例子中，稳定是跨 Pod (重新)调度的持久性的同义词。如果应用程序不需要任何稳定标识符或有序部署、删除或扩展，则应该使用提供一组无状态副本的工作负载对象来部署应用程序。部署或复制集可能更适合您的无状态需求。</p>
<h2 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h2><p>DaemonSet 保证所有（部分）节点运行一个 Pod 副本。一旦节点加入集群，Pods 就会加入这些节点。一旦节点从集群被删除，那些 Pods 也会被垃圾回收。删除 DaemonSet 会清除它创建的 Pods。</p>
<p>DaemonSet 典型应用：</p>
<ul>
<li><p>在每个节点上运行集群存储守护进程</p>
</li>
<li><p>在每个节点上运行日志收集守护进程</p>
</li>
<li><p>在每个节点上运行节点监控守护进程</p>
</li>
</ul>
<p>在一个简单的例子中，每种守护进程类型都使用一个覆盖所有节点的 DaemonSet。更复杂的设置可能会对单一类型的守护进程使用多个守护进程集，但是对于不同的硬件类型使用不同的标志和（或）不同的内存和 cpu 请求。</p>
<h2 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h2><p>Job 创建一个或多个 Pods，并且确保指定数量的 pod 成功终止。一旦 Pods 成功完成，Job 跟踪成功完成数据。当到底指定成功完成数量，Job 就完成了。删除 Job 会清除它创建的 Pods。</p>
<p>创建 Job 对象的简单应用场景是为了可靠地运行一个 Pods 到完成。当第一个 Pod 失败或者被删除，Job 对象会创建一个 Pod（例如节点硬件故障或者重启）。</p>
<h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><h2 id="TTL-Controller-for-Finished-resources"><a href="#TTL-Controller-for-Finished-resources" class="headerlink" title="TTL Controller for Finished resources"></a>TTL Controller for Finished resources</h2><p>TTL 控制器提供了一种 TTL(生存时间)机制来限制已完成执行的资源对象的生存期。TTL 控制器目前只处理 Job，可以扩展为处理其他将完成执行的资源，如 Pods 和自定义资源。</p>
<h2 id="CronJob"><a href="#CronJob" class="headerlink" title="CronJob"></a>CronJob</h2><p>CronJob 创建循环调度 Jobs。</p>
<p>一个 CronJob 对象类似于 crontab (cron 表)文件的一行。它以 Cron 格式编写，按照给定的调度周期运行作业。</p>
<h2 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h2><p>ReplicationController 保证在任意时刻运行指定数量的 pod 副本。换句话说，ReplicationController 确保 pod 或一组同质 pod 始终处于可用状态。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/22/k8s-workload-pod-init-container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/22/k8s-workload-pod-init-container/" class="post-title-link" itemprop="url">k8s-负载-pod-初始容器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-22 10:08:03 / 修改时间：16:03:07" itemprop="dateCreated datePublished" datetime="2020-12-22T10:08:03+08:00">2020-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="理解初始容器"><a href="#理解初始容器" class="headerlink" title="理解初始容器"></a>理解初始容器</h2><p>一个 Pod 可以运行多个应用容器，但是它也可以运行一个或多个能够在应用容器启动之前运行的初始容器。</p>
<p>初始容器就像普通容器，除了：</p>
<ul>
<li>初始容器总是会运行完成。</li>
<li>每个初始容器必须在下一个启动之前成功完成。</li>
</ul>
<p>如果 Pod 里初始容器失败，kubelet 会重启这个初始容器直到它成功。但是，如果 Pod 的 restartPolicy 是 Never，如果在 Pod 启动时初始容器失败， k8s 将标注整个 Pod 失败。</p>
<p>为了给 Pod 指定初始容器，在 Pod 描述中增加 initContainers 字段，作为一个容器类型的对象数组，紧邻应用 containers 数组。init 容器的状态在.status.initContainerStatuses 中返回,作为容器状态数组的 initContainerStatuses 字段(类似于.status.containerStatuses 字段)。</p>
<h3 id="与普通容器区别"><a href="#与普通容器区别" class="headerlink" title="与普通容器区别"></a>与普通容器区别</h3><p>初始容器支持应用容器的所有属性和特征，包括资源限制，数据卷和认证配置。但是，初始容器的资源请求和限制处理逻辑与应用容器不一样，详情可以参考<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/#resources">资源</a>文档</p>
<p>并且初始容器不支持 lifecycle, livenessProbe, readinessProbe, 或者 startupProbe，因为初始容器必须在 Pod 准备好之前完成。</p>
<p>如果为 Pod 指定多个初始化容器，kubelet 会按顺序运行每个初始化容器。每个初始化容器必须成功，下一个容器才能运行。当所有初始化容器都运行到完成时，kubelet 会初始化 Pod 的应用程序容器，并像往常一样运行它们。</p>
<h2 id="初始化容器使用"><a href="#初始化容器使用" class="headerlink" title="初始化容器使用"></a>初始化容器使用</h2><p>因为初始化容器有独立于应用容器的镜像，所以对于启动相关的代码来说，它们有一些优势：</p>
<ul>
<li>初始化容器可以包含应用程序镜像中不存在的实用程序或者自定义设置代码。例如，在安装过程中不需要使用 sed、awk、python 或 dig 等工具从另一个镜像生成镜像。</li>
<li>应用程序镜像构建器和部署器可以独立工作，而不需要联合构建单个应用程序映像。</li>
<li>初始化容器可以在与相同 Pod 中的应用程序容器不同的文件系统视图上运行。因此，他们可以访问应用容器无法访问的 Secrets 。</li>
<li>因为初始化容器在任何应用程序容器启动之前运行到完成，所以初始化容器提供了一种阻止或延迟应用程序容器启动的机制，直到满足一组先决条件。一旦满足了前提条件，一个Pod中的所有应用程序容器都可以并行启动。</li>
<li>初始化容器可以安全地运行工具或自定义代码，否则会使应用容器映像不那么安全。通过保持不必要的工具分离，你可以限制你的应用容器图像的攻击面。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/17/k8s-workload-pod-lifecycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/k8s-workload-pod-lifecycle/" class="post-title-link" itemprop="url">k8s-工作负载-pod-生命周期</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-17 18:43:44" itemprop="dateCreated datePublished" datetime="2020-12-17T18:43:44+08:00">2020-12-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-22 10:05:33" itemprop="dateModified" datetime="2020-12-22T10:05:33+08:00">2020-12-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本页主要描述 pod 生命周期。 Pod 遵循一个定义好的生命周期，创建时是 Pending 阶段，它里面只要有一个私有容器启动成功就变为 Running，根据最终是否存在任何容器失败变更状态为 Succeeded 或者 Failed。</p>
<p>当 Pod 运行时，kubelet 能够重新启动容器以处理某种类型的故障。在一个 Pod 内，k8s 跟踪不同的容器状态，并决定采取什么行动使 Pod 恢复健康。</p>
<p>在 k8s API 中，Pods 既有规范又有实际状态。Pod 对象的状态由一组 Pod 状态组成。如果对您的应用程序有用，您还可以将自定义信息注入到 Pod 的状态数据中。</p>
<p>Pods 在其生命周期中只会调度一次。一旦将 Pod 调度(分配)到某个节点，Pod 就会在该节点上运行，直到它停止或终止。</p>
<h2 id="Pod-阶段"><a href="#Pod-阶段" class="headerlink" title="Pod 阶段"></a>Pod 阶段</h2><img src="/2020/12/17/k8s-workload-pod-lifecycle/k8s-pod-phase.svg" class="" title="pod-phase">

<h2 id="容器状态"><a href="#容器状态" class="headerlink" title="容器状态"></a>容器状态</h2><ul>
<li><p>Waiting：如果容器状态不是 Running 或者 Terminated，状态就为 Waiting。</p>
</li>
<li><p>Running：Running 状态表示容器在没有问题的情况下执行。</p>
</li>
<li><p>Terminated：Terminated 状态的容器开始执行，然后要么运行到完成，要么由于某种原因失败。</p>
</li>
</ul>
<h2 id="容器重启策略"><a href="#容器重启策略" class="headerlink" title="容器重启策略"></a>容器重启策略</h2><p>Pod 的 spec 属性有个 restartPolicy 属性。这个属性可选值为 Always, OnFailure 和 Never，默认是 Always。</p>
<p>restartPolicy 应用于 Pod 里的所有容器。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/17/k8s-workload-pod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/k8s-workload-pod/" class="post-title-link" itemprop="url">k8s-工作负载-pod</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-17 15:36:45 / 修改时间：18:26:18" itemprop="dateCreated datePublished" datetime="2020-12-17T15:36:45+08:00">2020-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Pods 是可以在 k8s 中创建和管理的最小的可部署计算单元。</p>
<p>一个 Pod 是一组一个或多个容器，具有共享的存储/网络资源，以及如何运行这些容器的规范。Pod 的内容始终位于同一个位置并共同调度，并在共享上下文中运行。Pod 为特定于应用程序的“逻辑主机”建模:它包含一个或多个相对紧密耦合的应用程序容器。在非云环境中，在相同物理或虚拟机上执行的应用程序类似于在相同逻辑主机上执行的云应用程序。</p>
<p>与应用程序容器一样，Pod 可以包含在 Pod 启动期间运行的初始化容器。如果集群提供了这一功能，您还可以注入临时容器进行调试。</p>
<h2 id="What-is-a-Pod"><a href="#What-is-a-Pod" class="headerlink" title="What is a Pod"></a>What is a Pod</h2><p><strong>注意</strong>：虽然 k8s 支持更多的容器运行时，而不仅仅是 Docker, Docker 是最常见的运行时，它有助于使用 Docker 中的一些术语来描述 pod。</p>
<p>Pod 的共享上下文是一组 Linux 名称空间、cgroups，可能还有隔离的其他方面—与隔离 Docker 容器相同的内容。在 Pod 的上下文中，单个应用程序可能会应用进一步的子隔离。</p>
<p>就 Docker 概念而言，Pod 类似于一组具有共享名称空间和共享文件系统卷的 Docker 容器。</p>
<h2 id="Using-Pods"><a href="#Using-Pods" class="headerlink" title="Using Pods"></a>Using Pods</h2><p>常你不需要直接创建 Pods，甚至是单例的 Pods。相反，使用 Deployment 或 Job 等工作负载资源创建它们。如果您的 Pods 需要跟踪状态，请考虑 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a> 资源。</p>
<p>k8s 集群中的 pod 主要以两种方式使用:</p>
<ul>
<li>运行一个容器的 Pod：“一个容器一个 Pod”的模型是 k8s 最常见的使用案例;在这种情况下，您可以将 Pod 看作是围绕单个容器的包装器;k8s 管理 pod 而不是直接管理容器。</li>
<li>运行多个需要协同工作的容器的 Pod：一个 Pod 可以封装由多个紧密耦合且需要共享资源的位于同一位置的容器组成的应用程序。这些位于同一位置的容器形成了单一的内聚服务单元。例如，一个容器向公众提供存储在共享卷中的数据，而单独的 sidecar 容器则刷新或更新这些文件。Pod 将这些容器、存储资源和临时网络标识包装为一个单一单元。</li>
</ul>
<p><strong>注意</strong>：将多个位于同一位置并共同管理的容器分组到一个 Pod 中是一种相对高级的用例。您应该仅在容器紧密耦合的特定实例中使用此模式。</p>
<p>每个 Pod 都意味着运行给定应用程序的单个实例。如果您想水平扩展应用程序(通过运行更多实例来提供更多的整体资源)，您应该使用多个 pod，每个实例一个。在 k8s 中，这通常被称为复制。复制的 pod 通常由工作负载资源及其控制器作为一个组创建和管理。</p>
<p>有关 k8s 如何使用工作负载资源及其控制器来实现应用程序伸缩和自动修复的更多信息，请参见<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/#pods-and-controllers">Pods 和 controllers</a>。</p>
<h3 id="How-Pods-manage-multiple-containers"><a href="#How-Pods-manage-multiple-containers" class="headerlink" title="How Pods manage multiple containers"></a>How Pods manage multiple containers</h3><p>Pods 被设计用来支持多个协作流程(作为容器)，这些流程形成一个内聚的服务单元。Pod 中的容器在集群中的同一物理或虚拟机上自动地共同定位和调度。容器可以共享资源和依赖关系，相互通信，协调何时以及如何终止它们。</p>
<p>例如，您可能有一个容器充当共享卷中的文件的 web 服务器，以及一个单独的“sidecar”容器从远程源更新这些文件，如下图所示:</p>
<img src="/2020/12/17/k8s-workload-pod/pod.svg" class="" title="pod">

<p>一些 Pods 有 init 容器和 app 容器。Init 容器在应用程序容器启动之前运行并完成。</p>
<p>Pods 在本质上为其组成容器提供了两种共享资源:<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/#pod-networking">网络</a>和<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/pods/#pod-storage">存储</a>。</p>
<h2 id="Working-with-Pods"><a href="#Working-with-Pods" class="headerlink" title="Working with Pods"></a>Working with Pods</h2><p>很少会在 k8s 中直接创建单独的 Pod—即使是单例 Pod。这是因为 pod 被设计成相对短暂的一次性实体。当创建一个 Pod(由您直接创建，或由控制器间接创建)时，新的 Pod 将被安排在集群中的一个节点上运行。Pod 将保留在该节点上，直到 Pod 完成执行、删除 Pod 对象、由于缺乏资源而删除 Pod 或节点失败。</p>
<p><strong>注意</strong>：在一个容器中重新启动一个容器不应该与重新启动一个容器相混淆。Pod 不是一个进程，而是一个运行容器的环境。Pod 一直存在到被删除为止。</p>
<p>当您为 Pod 对象创建清单时，请确保指定的名称是有效的 DNS 子域名。</p>
<h3 id="Pods-and-controllers"><a href="#Pods-and-controllers" class="headerlink" title="Pods and controllers"></a>Pods and controllers</h3><p>您可以使用工作负载资源为您创建和管理多个 pod。资源的控制器处理复制和展开式，以及在 Pod 失败时的自动愈合。例如，如果一个节点发生故障，控制器会注意到该节点上的 Pod 已经停止工作，并创建一个替代 Pod。调度程序将替换 Pod 放置到健康节点上。</p>
<p>下面是一些管理一个或多个 pod 的工作负载资源示例:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">DaemonSet</a></li>
</ul>
<h3 id="Pod-templates"><a href="#Pod-templates" class="headerlink" title="Pod templates"></a>Pod templates</h3><p>工作负载资源的控制器从 pod 模板创建 pod，并代表您管理这些 pod。</p>
<p>PodTemplates 是用于创建 pod 的规范，包含在 Deployments、Jobs 和 DaemonSet 等工作负载资源中。</p>
<p>工作负载资源的每个控制器都使用工作负载对象内部的 PodTemplate 来制作实际的 pod。PodTemplate 是你用来运行应用程序的任何负载资源的期望状态的一部分。</p>
<p>下面的示例是一个简单作业的清单，该作业使用启动一个容器的模板。该容器中的容器打印一条消息，然后暂停。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="comment"># This is the pod template</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">          <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&#x27;echo &quot;Hello, Kubernetes!&quot; &amp;&amp; sleep 3600&#x27;</span>]</span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line">    <span class="comment"># The pod template ends here</span></span><br></pre></td></tr></table></figure>

<p>修改 pod 模板或切换到新的 pod 模板对已经存在的 pod 没有直接影响。如果您更改工作负载资源的 pod 模板，该资源需要创建使用更新模板的替换 pod。</p>
<p>例如，StatefulSet 控制器确保运行的 pod 与每个 StatefulSet 对象的当前 pod 模板匹配。如果您编辑 StatefulSet 以更改它的 pod 模板，StatefulSet 将开始基于更新后的模板创建新的 pod。最后，所有旧的 pod 都被新 pod 替换，更新就完成了。</p>
<p>每个工作负载资源实现自己的规则来处理对 Pod 模板的更改。如果您想更详细地了解 StatefulSet，请阅读 StatefulSet 基础教程中的更新策略。</p>
<p>在节点上，kubelet 不直接观察或管理 pod 模板和更新细节;这些细节都被抽象出来了。关注点的抽象和分离简化了系统语义，使扩展集群的行为在不更改现有代码的情况下变得可行。</p>
<h2 id="Resource-sharing-and-communication"><a href="#Resource-sharing-and-communication" class="headerlink" title="Resource sharing and communication"></a>Resource sharing and communication</h2><p>Pods 支持在其组成容器之间共享和通信数据。</p>
<h3 id="Storage-in-Pods"><a href="#Storage-in-Pods" class="headerlink" title="Storage in Pods"></a>Storage in Pods</h3><p>Pod 可以指定一组共享存储卷。Pod 中的所有容器都可以访问共享卷，从而允许这些容器共享数据。卷还允许 Pod 中的持久数据在其中一个容器需要重新启动的情况下继续存在。有关 k8s 如何实现共享存储并使其可用于 Pods 的更多信息，请参见 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/storage/">Storage</a>。</p>
<h3 id="Pod-networking"><a href="#Pod-networking" class="headerlink" title="Pod networking"></a>Pod networking</h3><p>为每个 Pod 分配一个地址族中唯一的 IP 地址。Pod 中的每个容器共享网络名称空间，包括 IP 地址和网络端口。在一个 Pod 中(只有这样)，属于 Pod 的容器才能使用本地主机与其他容器进行通信。当 Pod 中的容器与 Pod 外的实体通信时，它们必须协调如何使用共享网络资源(如端口)。在一个 Pod 中，容器共享一个 IP 地址和端口空间，并且可以通过本地主机找到彼此。Pod 中的容器还可以使用标准的进程间通信(如 SystemV 信号量或 POSIX 共享内存)相互通信。不同 Pod 中的容器有不同的 IP 地址，没有特殊的配置就不能通过 IPC 通信。希望与运行在不同 Pod 中的容器交互的容器可以使用 IP 网络进行通信。</p>
<p>Pod 中的容器将看到系统主机名与配置的 Pod 名相同。在网络部分有更多关于这方面的内容。</p>
<h3 id="Privileged-mode-for-containers"><a href="#Privileged-mode-for-containers" class="headerlink" title="Privileged mode for containers"></a>Privileged mode for containers</h3><p>Pod 中的任何容器都可以使用容器规范的安全上下文中的 privileged 标志启用特权模式。这对于希望使用操作系统管理功能(如操作网络堆栈或访问硬件设备)的容器非常有用。特权容器内的进程获得的特权几乎与容器外的进程获得的特权相同。</p>
<p><strong>注意</strong>：容器运行时必须支持特权容器的概念，才能与此设置相关。</p>
<h3 id="Static-Pods"><a href="#Static-Pods" class="headerlink" title="Static Pods"></a>Static Pods</h3><p>静态 pod 由特定节点上的 kubelet 守护进程直接管理，不需要 API 服务器观察它们。虽然大多数 Pod 是由控制平面管理的(例如，部署)，但是对于静态 Pod, kubelet 直接监督每个静态 Pod(并在它失败时重新启动它)。</p>
<p>静态 Pods 总是绑定到特定节点上的一个 Kubelet。静态 Pods 的主要用途是运行一个自托管的控制层:换句话说，使用 kubelet 来监督各个控制层组件。</p>
<p>kubelet 会自动尝试在 k8s API 服务器上为每个静态 Pod 创建一个镜像 Pod。这意味着在一个节点上运行的 Pods 在 API 服务器上是可见的，但不能从那里进行控制。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/17/k8s-workload-knowledge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/k8s-workload-knowledge/" class="post-title-link" itemprop="url">k8s-工作负载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-17 15:23:24 / 修改时间：15:34:26" itemprop="dateCreated datePublished" datetime="2020-12-17T15:23:24+08:00">2020-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>工作负载是运行在 k8s 上的应用程序。无论您的工作负载是单个组件还是多个协同工作的组件，在 k8s 上，您都可以在一组 pod 中运行它。在 k8s 中，一个 Pod 表示集群上一组运行的容器。</p>
<p>Pod 具有已定义的生命周期。例如，一旦一个 Pod 在集群中运行，那么该 Pod 所在节点上的一个严重故障意味着该节点上的所有 Pod 都失败了。k8s 将这种级别的故障视为最终级别:即使节点稍后恢复，也需要创建一个新的 Pod。</p>
<p>但是，为了大大简化工作，您不需要直接管理每个 Pod。相反，可以使用代表您管理一组 pod 的工作负载资源。这些资源配置控制器，以确保正确种类的 Pod 的正确数量正在运行，以匹配您指定的状态。</p>
<p>工作负载资源包括：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a> 和 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a> (替换遗留资源 ReplicationController);</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/">DaemonSet</a>（用于运行提供节点本地设备的 pod，如存储驱动程序或网络插件）</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">Job</a> 和<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a>。</li>
</ul>
<p>还有两个支持的概念，你可能会觉得相关:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/">Garbage collection</a>：在删除集群中拥有资源的对象后，对它们进行整理。</li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/workloads/controllers/ttlafterfinished/">time-to-live after finished controller</a>：在作业完成后的定义时间过后，删除作业。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/17/k8s-cluster-architecture-controller/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/k8s-cluster-architecture-controller/" class="post-title-link" itemprop="url">k8s-集群架构-控制器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-17 13:37:10 / 修改时间：14:08:19" itemprop="dateCreated datePublished" datetime="2020-12-17T13:37:10+08:00">2020-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在机器人技术和自动化技术中，控制回路是调节系统状态的无终止回路。</p>
<p>这是一个控制回路的例子:房间里的恒温器。</p>
<p>当你设置温度时，它告诉恒温器你想要的状态。实际室温是当前的状态。恒温器的作用是打开或关闭设备，使当前状态更接近所需的状态。</p>
<p>在 k8s 中，控制器是监控集群状态的控制循环，然后在需要的地方进行或请求更改。每个控制器都试图将当前集群状态移动到更接近期望状态的位置。</p>
<h2 id="控制器模式"><a href="#控制器模式" class="headerlink" title="控制器模式"></a>控制器模式</h2><p>控制器跟踪至少一种 k8s 资源类型。这些对象有一个 spec 字段表示所需的状态。该资源的控制器负责使当前状态更接近所期望的状态。</p>
<p>控制器可以自己执行动作;更常见的是，在 k8s 中，控制器将向 API server 发送具有有用副作用的消息。将在下面看到这样的示例。</p>
<h3 id="基于-API-server-控制"><a href="#基于-API-server-控制" class="headerlink" title="基于 API server 控制"></a>基于 API server 控制</h3><p>Job 控制器是 k8s 内置控制器的一个例子。内置控制器通过与集群 API server 交互来管理状态。</p>
<p>Job 是 k8s 资源，它运行一个 pod(可能是几个 pods)来执行一个任务，然后停止。</p>
<p>(一旦调度成功，Pod 对象将成为 kubelet 所需状态的一部分)。</p>
<p>当 Job 控制器获得一个新任务时，它将确保在集群中的某个位置，一组节点上的 kubelets 正在运行正确数量的 pod 以完成工作。Job 控制器本身不运行任何 pod 或容器。相反，Job 控制器告诉 API 服务器创建或删除 pod。控制层中的其他组件对新信息进行操作(有新的 pod 来调度和运行)，并最终完成工作。</p>
<p>在创建新 Job 之后，期望的状态是该 Job 已完成。Job 控制器使该 Job 的当前状态更接近您想要的状态:创建 Pods 来完成您想要完成的工作，这样 Job 就更接近完成了。</p>
<p>控制器还更新配置它们的对象。例如:一旦某一 Job 的工作完成，Job 控制器就更新该 Job 对象以标记它已完成。</p>
<p>(这有点像恒温器关闭一盏灯，以显示房间现在的温度是你设定的)。</p>
<h3 id="直接控制"><a href="#直接控制" class="headerlink" title="直接控制"></a>直接控制</h3><p>与 Job 相比，一些控制器需要对集群之外的事物进行更改。</p>
<p>例如，如果使用控制循环来确保集群中有足够的节点，那么该控制器需要当前集群之外的某些东西来在需要时设置新节点。</p>
<p>与外部状态交互的控制器从 API server 找到它们想要的状态，然后直接与外部系统通信，使当前状态更加一致。</p>
<p>(实际上有一个控制器可以水平扩展集群中的节点。)</p>
<p>这里重要的一点是，控制器进行一些更改以实现所需的状态，然后将当前状态报告回集群的 API server。其他控制循环可以观察报告的数据并采取自己的操作。</p>
<p>在恒温器的例子中，如果房间非常冷，另一个控制器可能也会打开防冻加热器。通过 k8s 集群，控制层通过扩展 k8s 来间接地与 IP 地址管理工具、存储服务、云提供商 api 和其他服务协同工作。</p>
<h2 id="期望状态和当前状态"><a href="#期望状态和当前状态" class="headerlink" title="期望状态和当前状态"></a>期望状态和当前状态</h2><p>k8s 从云计算的角度看待系统，能够应对不断的变化。</p>
<p>在工作发生和控制回路自动修复故障时，您的集群随时可能发生更改。这意味着，您的集群可能永远不会达到稳定状态。</p>
<p>只要集群的控制器在运行并能够进行有益的更改，那么总体状态是否稳定就无关紧要了。</p>
<h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>作为其设计的原则，k8s 使用许多控制器，每个控制器管理集群状态的一个特定方面。最常见的是，一个特定的控制循环(控制器)使用一种资源作为它想要的状态，并拥有一种不同类型的资源，它管理这些资源使它想要的状态发生。例如，Job 控制器跟踪 Job 对象(以发现新 Job)和 Pod 对象(以运行 Job，然后查看 Job 何时完成)。在本例中，其他东西创建 Job，而 Job 控制器创建 pod。</p>
<p>使用简单的控制器比使用一套单一的、相互连接的控制回路更有用。控制器可能会出现故障，所以 k8s 的设计允许这种情况发生。</p>
<p><strong>注意</strong>：</p>
<ul>
<li><p>可以有多个控制器创建或更新同一类型的对象。在幕后，k8s 控制器确保只关注与控制资源相关联的资源。</p>
</li>
<li><p>例如，可以有 Deployments 和 Jobs;它们都可以创建了 pods。Job 控制器不会删除 Deployment 创建的 pod，因为控制器可以使用信息(标签)来区分这些 pod。</p>
</li>
</ul>
<h2 id="运行控制器的方式"><a href="#运行控制器的方式" class="headerlink" title="运行控制器的方式"></a>运行控制器的方式</h2><p>k8s 自带一组运行在 kube-controller-manager 内部的内置控制器。这些内置控制器提供了重要的核心行为。</p>
<p>Deployment 控制器和 Job 控制器是作为 k8s 自身一部分的控制器(内置控制器)的例子。k8s 允许你运行一个弹性控制层，这样如果任何内置控制器出现故障，控制层的另一部分将接管工作。</p>
<p>你可以找到运行在控制层外的控制器，以扩展 k8s。或者，如果您愿意，您可以自己编写一个新的控制器。你可以运行你自己的控制器作为一组 Pods，或外部 k8s。什么最适合取决于特定控制器的操作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/17/k8s-cluster-architecture-control-plane-node-communication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/17/k8s-cluster-architecture-control-plane-node-communication/" class="post-title-link" itemprop="url">k8s-集群架构-控制层与节点通信</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-17 13:06:46 / 修改时间：13:31:49" itemprop="dateCreated datePublished" datetime="2020-12-17T13:06:46+08:00">2020-12-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文对控制层(实际上是 apiserver)和 k8s 集群之间的通信路径进行了分类。其目的是允许用户自定义安装来加强网络配置，这样集群就可以运行在一个不可信的网络上(或在一个云提供商上的完全公共的 ip 上)。</p>
<h2 id="节点到控制层"><a href="#节点到控制层" class="headerlink" title="节点到控制层"></a>节点到控制层</h2><p>k8s 有一个’中心辐射式’API 模式。来自节点(或它们运行的 pod)的所有 API 使用都在 apiserver 终止(其他控制层组件都不用于公开远程服务)。apiserver 被配置为侦听安全 HTTPS 端口(通常为 443)上的远程连接，并且启用了一种或多种形式的客户端身份验证。应该启用一种或多种形式的授权，特别是在允许匿名请求或服务帐户令牌的情况下。</p>
<p>应该为节点提供集群的公共根证书，这样它们就可以使用有效的客户机凭证安全地连接到 apiserver。一种好的方法是，提供给 kubelet 的客户机凭据是以客户机证书的形式提供的。请参阅<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/">kubelet TLS bootstrapping</a>，以自动提供 kubelet 客户端证书。</p>
<p>希望连接到 apiserver 的 pod 可以通过利用一个服务帐户安全地做到这一点，以便 k8s 在实例化 pod 时自动将公共根证书和有效的无记名令牌注入到 pod 中。k8s 服务(在所有命名空间中)都配置了一个虚拟 IP 地址，该地址被重定向(通过 kube-proxy)到 apiserver 上的 HTTPS 端点。</p>
<p>控制层组件也通过安全端口与集群 apiserver 通信。</p>
<p>因此，从节点和节点上运行的 pods 到控制层的连接的默认操作模式在缺省情况下是安全的，并且可以在不可信的以及公共网络上运行。</p>
<h2 id="控制层到节点"><a href="#控制层到节点" class="headerlink" title="控制层到节点"></a>控制层到节点</h2><p>从控制层(apiserver)到节点有两条主要通信路径。第一个是从 apiserver 到 kubelet 进程，该进程在集群中的每个节点上运行。第二种是通过 apiserver 的代理功能从 apiserver 到任何 node、pod 或 service。</p>
<h3 id="apiserver-到-kubelet"><a href="#apiserver-到-kubelet" class="headerlink" title="apiserver 到 kubelet"></a>apiserver 到 kubelet</h3><p>从 apiserver 到 kubelet 的连接用于:</p>
<ul>
<li>抓取 Pods 日志。</li>
<li>(通过 kubectl)进入运行 Pods。</li>
<li>提供 kubelet 的端口转发功能。</li>
</ul>
<p>这些连接在 kubelet 的 HTTPS 端点终止。默认情况下，apiserver 不验证 kubelet 的服务证书，这使得连接受到中间人攻击，并且在不受信任的和/或公共网络上运行是不安全的。</p>
<p>要验证此连接，请使用–kubelet-certificate-authority 标志为 apiserver 提供根证书包，用于验证 kubelet 的服务证书。</p>
<p>如果这是不可能的，请在需要时使用 apiserver 和 kubelet 之间的 SSH 隧道，以避免通过不可信的或公共的网络进行连接。</p>
<p>最后，应该启用 Kubelet 身份验证和/或授权来保护 Kubelet API。</p>
<h3 id="apiserver-到-nodes，pods-和-services"><a href="#apiserver-到-nodes，pods-和-services" class="headerlink" title="apiserver 到 nodes，pods 和 services"></a>apiserver 到 nodes，pods 和 services</h3><p>从 apiserver 到节点、pod 或服 service 的连接默认为纯 HTTP 连接，因此既没有经过身份验证也没有加密。他们可以运行在一个安全的 HTTPS 连接通过加前缀 HTTPS:node,pod,或 service 名称的 API URL,但他们不会验证证书提供的 HTTPS 端点也提供客户端凭证所以当连接将被加密,它不会提供任何担保的完整性。这些连接当前在不受信任和/或公共网络上运行是不安全的。</p>
<h3 id="ssh-隧道"><a href="#ssh-隧道" class="headerlink" title="ssh 隧道"></a>ssh 隧道</h3><p>k8s 支持 SSH 隧道，以保护控制层到节点的通信路径。在此配置中，apiserver 启动一个 SSH 通道到集群中的每个节点(连接到侦听端口 22 的 SSH 服务器)，并通过通道传递所有以 kubelet、node、pod 或 service 为目的地的流量。这个隧道确保了通信量不会暴露在正在运行的节点所在的网络之外。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/14/k8s-cluster-architecture-nodes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/14/k8s-cluster-architecture-nodes/" class="post-title-link" itemprop="url">k8s-集群架构-节点</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-14 11:44:04" itemprop="dateCreated datePublished" datetime="2020-12-14T11:44:04+08:00">2020-12-14</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-17 13:04:49" itemprop="dateModified" datetime="2020-12-17T13:04:49+08:00">2020-12-17</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>K8s 通过将容器放置到 Pods 中以在 Nodes 上运行来运行工作负载。节点可以是虚拟机或者物理机，取决于集群。每个节点都有包含有控制层管理的运行 Pods 的必要服务。</p>
<p>集群通常有几个节点，在学习环境或者资源有限，也可以只有一个节点。</p>
<p>节点上的组件包括 kubelet, container runtime 和 kube-proxy。</p>
<h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><p>有两种主要方法可以将节点添加到 API server：</p>
<ul>
<li>节点上的 kubelet 自动注册到控制层。</li>
<li>用户手动添加节点对象。</li>
</ul>
<p>在手动创建节点对象或者节点上的 kubelet 自动注册之后，控制层将检查节点是否可用。例如，可以尝试通过以下 json 显示地创建一个节点：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Node&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;10.240.79.157&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;labels&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;my-first-k8s-node&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>k8s 在内部创建一个节点对象。k8s 检查 kubelet 是否已注册到与节点的 metada.name 字段匹配的 API 服务器。如果节点是健康的（所有服务都正常运行），节点就是和运行 Pod。否则的话，节点就会被任何可用集群忽略，直到节点重新变为可用。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>k8s 保留不可用节点对象并且持续检查这个节点是否变为可用。</li>
<li>管理员想要停止健康检查时，必须删除节点对象。</li>
</ul>
<p>节点的名字必须是一个可用的 <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/overview/working-with-objects/names#dns-subdomain-names">DNS 子域名称</a></p>
<h3 id="节点自动注册"><a href="#节点自动注册" class="headerlink" title="节点自动注册"></a>节点自动注册</h3><p>当 kubelet 标识 –register-node 是 true 时，kubelet 将向 API server 注册自己。这是大多数发行版所使用的首选模式。</p>
<p>对于自动注册，kubelet 使用以下选项启动：</p>
<ul>
<li>–kubeconfig：向 API server 验证自身的凭据路径。</li>
<li>–cloud-provider： 如何与云提供商对话以读取关于其自身的元数据。</li>
<li>–register-node：自动注册 API server。</li>
<li>–register-with-taints：用给定的污染列表注册节点（逗号分割<key>=<value>:<effect>）。如果 register-node 为 false，则无操作。</li>
<li>–node-ip： 节点的 IP 地址。</li>
<li>–node-labels：在集群中注册节点时要添加的标签。（通过<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a>查询强制执行的标签）</li>
<li>–node-status-update-frequency：指定 kubelet 将节点状态提交给 master 的频率。</li>
</ul>
<p>当<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/node/">Node authorization mode</a>和<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction">NodeRestriction admission plugin</a>可用时，k8s 只被授权创建和更新节点资源。</p>
<h2 id="人工节点管理"><a href="#人工节点管理" class="headerlink" title="人工节点管理"></a>人工节点管理</h2><p>可以通过 kubectl 创建和修改节点对象。</p>
<p>当需要手动创建节点时，需要设置 kubelet 标识–register-node=false。</p>
<p>无论–register-node 的设置如何，都可以修改节点对象。比如，可以给已有节点设置标签，或者将它标记为 unschedulable。</p>
<p>可以将节点上的标签与 Pods 上的节点选择器结合使用，以控制调度。例如，可以约束一个 Pod，使其只适合在可用节点的子集上运行。</p>
<p>将节点标记为 unschedulable 可以防止调度器将新 pods 放到该节点上，但不会影响该节点上的现有 pods。作为节点重启或其他维护之前的准备步骤，这非常有用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将节点标记为不可用</span></span><br><span class="line">kubectl cordon $NODENAME</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将pod驱赶到其他节点</span></span><br><span class="line">kubectl drain $NODENAME</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解除不可调度状态</span></span><br><span class="line">kubectl uncordon $NODENAME</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：作为守护进程的一部分的 Pods 允许在不可调度的节点上运行。DaemonSets 通常提供应该在节点上运行的节点本地服务，即使工作负载应用程序正在耗尽节点。</p>
<h2 id="节点状态"><a href="#节点状态" class="headerlink" title="节点状态"></a>节点状态</h2><p>节点状态包括以下信息：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/#addresses">Address</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/#condition">Conditions</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/#capacity">Capacity and Allocatable</a></li>
<li><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/architecture/nodes/#info">Info</a></li>
</ul>
<p>可以使用 kubectl 查看节点状态和其他详情：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe node &lt;insert-node-name-here&gt;</span><br></pre></td></tr></table></figure>

<p>下面描述输出的每个部分。</p>
<h3 id="Address"><a href="#Address" class="headerlink" title="Address"></a>Address</h3><p>这些字段的使用取决于云提供商或裸机配置。</p>
<ul>
<li>HostName：由节点的内核报告的主机名。可以通过 kubelet –hostname-override 参数替换。</li>
<li>ExternalIP：通常是外部可路由的节点的 IP 地址(从集群外部可用)。</li>
<li>InternalIP：通常是仅在集群内可路由的节点的 IP 地址。</li>
</ul>
<h3 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h3><p>Conditions 属性描述所有运行节点的状态。</p>
<table>
<thead>
<tr>
<th align="left">Node Condition</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ready</td>
<td align="left">如果节点运行正常并准备接受 pods，则为 True;如果节点运行不正常且不接受 pods，则为 False;如果节点控制器在最后一个节点-monitor-grace-period(缺省值为 40 秒)中没有听到该节点的消息，则为 Unknown。</td>
</tr>
<tr>
<td align="left">DiskPressure</td>
<td align="left">如果磁盘大小存在压力，即磁盘容量较低，则为 True;否则 False</td>
</tr>
<tr>
<td align="left">MemoryPressure</td>
<td align="left">如果节点内存存在压力，即节点内存较低，则为 True;否则 False</td>
</tr>
<tr>
<td align="left">PIDPressure</td>
<td align="left">如果进程存在压力，即节点上有太多进程，则为 True;否则 False</td>
</tr>
<tr>
<td align="left">NetworkUnavailable</td>
<td align="left">如果节点的网络配置不正确，则为 True，否则为 False</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：如果使用命令行工具打印被禁节点的详细信息，条件包括 SchedulingDisabled。在 k8s API 中，SchedulingDisabled 不是一个状态;相反，被封锁的节点在其规范中被标记为 Unschedulable。</p>
<p>节点状态表示为 JSON 对象。例如，下面的结构描述了一个健康的节点：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;conditions&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;Ready&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;True&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;reason&quot;</span>: <span class="string">&quot;KubeletReady&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;kubelet is posting ready status&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastHeartbeatTime&quot;</span>: <span class="string">&quot;2019-06-05T18:38:35Z&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lastTransitionTime&quot;</span>: <span class="string">&quot;2019-06-05T11:41:27Z&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>如果 Ready 的状态保持未知或者 False 的时间超过了 pod-eviction-timeout(kube-controller-manager 的参数)，节点上的所有 Pod 将被节点控制器安排删除。默认的收回超时持续时间是 5 分钟。在某些情况下，当节点不可访问时，API 服务器无法与节点上的 kubelet 通信。在重新建立与 API 服务器的通信之前，不能将删除 pod 的决定通知 kubelet。在此期间，计划删除的 pod 可能会继续运行。</p>
<p>节点控制器在确认 pod 在集群中停止运行之前不会强制删除 pod。可以看到在不可到达的节点上运行的 pods 处于终止状态或未知状态。如果 k8s 无法推断出一个节点是否永久离开了一个集群，那么集群管理员可能需要手动删除节点对象。从 k8s 中删除节点对象将导致从 API 服务器中删除运行在节点上的所有 Pod 对象，并释放它们的名称。</p>
<p>节点生命周期控制器自动创建表示条件的污点。调度程序在将 Pod 分配给节点时将节点的污点考虑在内。Pods 还可以具有允许它们容忍节点污染的容忍度。</p>
<p>有关详细信息，请参见<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/#taint-nodes-by-condition">Taint Nodes By Condition</a>。</p>
<h3 id="Capacity-and-Allocatable"><a href="#Capacity-and-Allocatable" class="headerlink" title="Capacity and Allocatable"></a>Capacity and Allocatable</h3><p>描述节点上可用的资源:CPU、内存和可以调度到节点上的 pod 的最大数量。</p>
<p>Capacity 字段表示一个节点所拥有的资源总量。Allocatable 表示一个节点上可被普通 pod 消耗的资源量。</p>
<p>在学习如何在节点上<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable">保留计算资源</a>时，您可以阅读更多关于容量和可分配资源的信息。</p>
<h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>描述关于节点的一般信息，如内核版本、k8s 版本(kubelet 和 kube-proxy 版本)、Docker 版本(如果使用)和 OS 名称。该信息由 Kubelet 从节点收集。</p>
<h3 id="Node-controller"><a href="#Node-controller" class="headerlink" title="Node controller"></a>Node controller</h3><p>节点控制器是一个 k8s 控制层组件，它管理节点的各个方面。</p>
<p>节点控制器在节点的生命周期中有多种角色。第一种是在注册节点时给节点分配一个 CIDR 块(如果 CIDR 分配打开了)。</p>
<p>第二种方法是使节点控制器的内部节点列表与云提供商的可用机器列表保持最新。当在云环境中运行时，只要某个节点不健康，节点控制器就会询问云提供商该节点的 VM 是否仍然可用。否则，节点控制器将从其节点列表中删除该节点。</p>
<p>第三个是监视节点的健康状况。当一个节点成为不可用时（即节点控制器停止接收心跳出于某些原因，例如由于节点宕机），节点控制器负责更新 NodeReady 的节点状态到 ConditionUnknown(,),然后如果节点仍然是不可用，那么会将节点上所有的 Pods 驱逐(使用优美的终止)。(默认超时是 40s 开始报告 ConditionUnknown, 5m 之后开始驱逐 pod。)节点控制器在节点监视器周期内检查每个节点的状态。</p>
<h3 id="Heartbeats"><a href="#Heartbeats" class="headerlink" title="Heartbeats"></a>Heartbeats</h3><p>由 k8s 节点发送的心跳帮助确定节点的可用性。</p>
<p>心跳有两种形式:NodeStatus 和 Lease 对象的更新。每个节点在 kube-node-lease 名称空间中都有一个相关联的 Lease 对象。Lease 是一种轻量级资源，它可以随着集群的扩展提高节点心跳的性能。</p>
<p>kubelet 负责创建和更新 NodeStatus 和 Lease 对象：</p>
<ul>
<li><p>kubelet 在状态发生变化时更新节点状态，或者在配置的时间间隔内没有更新。NodeStatus 更新的默认间隔是 5 分钟(远远长于无法到达节点的 40 秒默认超时)。</p>
</li>
<li><p>kubelet 每 10 秒创建并更新其租赁对象(默认的更新间隔)。租约更新独立于节点状态更新发生。如果租约更新失败，kubelet 将以指数回退的方式重试，起始时间为 200 毫秒，上限为 7 秒。</p>
</li>
</ul>
<h3 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h3><p>在大多数情况下，节点控制器将回收速率限制为——节点回收速率(默认值为 0.1)每秒，这意味着它每 10 秒不会从超过 1 个节点中回收 pod。</p>
<p>当给定可用性区域中的节点变得不健康时，节点退出行为将发生变化。节点控制器同时检查区域中有多少节点是不健康的(NodeReady 状态是 ConditionUnknown 或 ConditionFalse)。如果不健康的节点的分数至少–unhealthy-zone-threshold (默认 0.55)然后驱逐率是减少:如果集群很小(即小于或等于–large-cluster-size-threshold 节点默认 50)驱逐就停止,否则驱逐率降低到–secondary-node-eviction-rate (默认 0.01)每秒。每个可用性区域实现这些策略的原因是，一个可用性区域可能与主可用性区域分离，而其他可用性区域保持连接。如果您的集群没有跨越多个云提供商可用性区域，那么就只有一个可用性区域(整个集群)。</p>
<p>将节点分布到多个可用性区域的一个关键原因是，这样当整个区域出现故障时，可以将工作负载转移到健康区域。因此，如果一个区域中的所有节点都不健康，那么节点控制器将以正常的节点驱逐率(node-eviction-rate)进行驱逐。最极端的情况是所有区域都完全不健康(即集群中没有健康节点)。在这种情况下，节点控制器假定主连接有问题，并停止所有收回操作，直到恢复某些连接为止。</p>
<p>节点控制器还负责清除运行在带有 NoExecute 污染的节点上的 pod，除非这些 pod 容忍这种污染。节点控制器还添加了与节点问题(如节点不可用或未就绪)相对应的污点。这意味着调度器不会将 pod 放置到不健康的节点上。</p>
<p><strong>警告</strong>：kubectl cordon 将一个节点标记为’unschedulable’，这样做的副作用是服务控制器从任何负载均衡器节点目标列表中删除该节点，它以前是合格的，有效地从被封锁的节点中删除传入的负载均衡器流量。</p>
<h3 id="Node-capacity"><a href="#Node-capacity" class="headerlink" title="Node capacity"></a>Node capacity</h3><p>节点对象跟踪关于节点资源容量的信息(例如:可用内存量和 cpu 数量)。自我注册的节点在注册期间报告它们的容量。如果手动添加节点，则需要在添加节点时设置节点的容量信息。</p>
<p>k8s 调度程序确保一个节点上有足够的资源供所有 pod 使用。调度程序检查该节点上容器请求的总和是否大于该节点的容量。请求的总和包括 kubelet 管理的所有容器，但不包括直接由容器运行时启动的任何容器，也不包括在 kubelet 控制之外运行的任何进程。</p>
<p><strong>注意</strong>：如果希望显式地为非pod进程保留资源，请参阅<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved">系统守护进程的保留资源</a>。<br>`</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/11/k8s-objects-field-selector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/11/k8s-objects-field-selector/" class="post-title-link" itemprop="url">k8s-对象属性选择器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-12-11 17:08:43" itemprop="dateCreated datePublished" datetime="2020-12-11T17:08:43+08:00">2020-12-11</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-12-14 11:41:39" itemprop="dateModified" datetime="2020-12-14T11:41:39+08:00">2020-12-14</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>属性选择器允许基于一个或多个资源属性获取k8s资源。属性请求的示例：</p>
<ul>
<li>metadata.name=my-service</li>
<li>metadata.namespace!=default</li>
<li>status.phase=Pending</li>
</ul>
<p>使用kubectl命令查询所有status.phase属性值为Running的Pods:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --field-selector status.phase=Running</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: 属性选择器本质上是资源过滤器。默认情况下，没有使用选择器或者过滤器，意味着指定类型的所有资源都会被选中。</p>
<h2 id="支持的属性"><a href="#支持的属性" class="headerlink" title="支持的属性"></a>支持的属性</h2><p>受支持的字段选择器因k8s资源类型而异。所有资源类型都支持metadata.name和metadata.namespace字段。使用不支持的字段选择器会产生错误。例如:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ingress --field-selector foo.bar=baz</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error from server (BadRequest): Unable to find &quot;ingresses&quot; that match label selector &quot;&quot;, field selector &quot;foo.bar=baz&quot;: &quot;foo.bar&quot; is not a known field selector: only &quot;metadata.name&quot;, &quot;metadata.namespace&quot;</span><br></pre></td></tr></table></figure>

<h2 id="支持的运算符"><a href="#支持的运算符" class="headerlink" title="支持的运算符"></a>支持的运算符</h2><p>可以在字段选择器中使用=、==和!=操作符(=和==意思相同)。例如，这个kubectl命令选择不在默认名称空间中的所有K8s服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services  --all-namespaces --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure>

<h2 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h2><p>与标签和其他选择器一样，属性选择器可以作为逗号分隔的列表组合在一起。这个kubectl命令选择状态为其的所有Pods(status.phase不等于Running，spec.restartPolicy等于Always）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods --field-selector=status.phase!=Running,spec.restartPolicy=Always</span><br></pre></td></tr></table></figure>

<h2 id="多个资源类型"><a href="#多个资源类型" class="headerlink" title="多个资源类型"></a>多个资源类型</h2><p>可以跨多个资源类型使用属性选择器。这个kubectl命令选择不在default命名空间中的所有Statefulsets和Services</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!=default</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://qianqiuzhifeng.github.io/2020/12/11/k8s-objects-annotation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="浅秋之枫">
      <meta itemprop="description" content="随堂笔记">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浅秋之枫">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/12/11/k8s-objects-annotation/" class="post-title-link" itemprop="url">k8s-对象注释</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-12-11 16:24:35 / 修改时间：17:04:58" itemprop="dateCreated datePublished" datetime="2020-12-11T16:24:35+08:00">2020-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s/" itemprop="url" rel="index"><span itemprop="name">k8s</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>可以使用 k8s 注释将任意非标识元数据附加到对象。工具和库等客户端可以检索此元数据。</p>
<h2 id="对象添加元数据"><a href="#对象添加元数据" class="headerlink" title="对象添加元数据"></a>对象添加元数据</h2><p>可以使用标签或注释将元数据附加到 k8s 对象。标签可用于选择对象和查找满足特定条件的对象集合。相反，注释不用于标识和选择对象。注释中的元数据可以大可以小，可以是结构化的，也可以是非结构化的，还可以包含标签不允许的字符。</p>
<p>注释和标签一样，也是键值对集合：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;metadata&quot;: &#123;</span><br><span class="line">  &quot;annotations&quot;: &#123;</span><br><span class="line">    &quot;key1&quot; : &quot;value1&quot;,</span><br><span class="line">    &quot;key2&quot; : &quot;value2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一些可以记录在注释中的信息示例:</p>
<ul>
<li><p>由声明性配置层管理的字段。将这些字段作为注释附加，可以将它们与客户机或服务器设置的默认值、自动生成的字段和由自动调整大小或自动伸缩系统设置的字段区分开来。</p>
</li>
<li><p>构建、发布或图像信息，如时间戳、发布 id、git 分支、PR 号、图像散列和注册表地址。</p>
</li>
<li><p>指向日志记录、监视、分析或审计存储库的指针。</p>
</li>
<li><p>可用于调试目的的客户端库或工具信息:例如，名称、版本和构建信息。</p>
</li>
<li><p>用户或者工具/系统来源信息，例如来自其他生态系统组件的相关对象的 url。</p>
</li>
<li><p>轻量级的推出工具元数据:例如，配置或检查点。</p>
</li>
<li><p>负责人员的电话或寻呼机号码，或指定查找信息位置的目录项，如团队网站。</p>
</li>
<li><p>终端用户向实现发送的指令，用于修改行为或使用非标准特性。</p>
</li>
</ul>
<p>可以不使用注释，而将这种类型的信息存储在外部数据库或目录中，但是这样会使生成用于部署、管理、内省等的共享客户机库和工具变得更加困难。</p>
<h2 id="表达式和字符集"><a href="#表达式和字符集" class="headerlink" title="表达式和字符集"></a>表达式和字符集</h2><p>注释是键值对。有效的注释键有两个段:可选的前缀和名称，由斜杠(/)分隔。名称段是必需的，必须小于 63 个字符，开头和结尾为字母数字字符([a-z0-9A-Z])，中间有破折号(-)、下划线(_)、点号(.)和字母数字。前缀是可选的。如果指定，前缀必须是一个 DNS 子域:由点(.)分隔的一系列 DNS 标签，总长度不超过 253 个字符，后跟斜杠(/)。</p>
<p>如果省略了前缀，则将该注释键假定为用户的私有。向最终用户对象添加注释的自动化系统组件(例如 kube-scheduler、kube-controller-manager、kube-apiserver、kubectl 或其他第三方自动化)必须指定一个前缀。</p>
<p>kubernetes.io/和 k8s.io/前缀时为 k8s 核心组件保留的。</p>
<p>例如，这是一个有注释(imageregistry: <a target="_blank" rel="noopener" href="https://hub.docker.com/)%E7%9A%84Pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">https://hub.docker.com/)的Pod配置文件</a>:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">annotations-demo</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">imageregistry:</span> <span class="string">&quot;https://hub.docker.com/&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.14.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">浅秋之枫</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  







  






</body>
</html>
